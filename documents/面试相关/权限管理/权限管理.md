

# SpringSecurity

- 认证 （你是谁）
- 授权 （你能干什么）

使用众多的拦截器对url拦截，以此来管理权限。

首先，权限管理离不开登陆验证的，所以登陆验证拦截器AuthenticationProcessingFilter

还有就是对访问的资源管理吧，所以资源管理拦截器AbstractSecurityInterceptor要讲







+ 超级管理员能创建新的管理员账号、创建新的管理员角色、能分配角色给其他的管理员、创建新的资源、创建新的目录、给角色分配新的资源、给角色分配新的目录、创建资源目录、给资源分配资源目录







# 流程

+ 访问一个api，会到自定义拦截器，
+ 用了一个缓存configAttributeMap存储拥有的所有资源，为空则查数据库。key为url，值为资源的id+name
+ 获取当前访问路径，例如：/category/listAll
+ 将configAttributeMap中所有url路径和/category/listAll进行匹配，匹配到则加入configAttributes中，类似："9:菜单管理",代表的是该api路径所需要的资源
+ 然后如果CollUtil.isEmpty(configAttributes)，代表没有对这个api设置资源，则不会拦截。
+ 如果有，则和用户拥有的资源：authentication.getAuthorities()逐个对比，都有才放行



## 用户登录

用户登录会把所有资源查询出来存入缓存中，查询sql：

```
select distinct admin_resource.*
        from admin_user_role
                 join admin_role on admin_user_role.role_id = admin_role.id
                 join admin_role_resource on admin_role.id = admin_role_resource.role_id
                 join admin_resource on admin_role_resource.resource_id = admin_resource.id
        where admin_user_role.user_id = #{userId}
          and admin_role.status = 1
          and admin_resource.status = 1;
```



```
//返回当前用户拥有的资源权限
        return resourceList.stream()
                .map(AdminResource -> new SimpleGrantedAuthority(AdminResource.getId() + ":" + AdminResource.getName()))
                .collect(Collectors.toList());
```

