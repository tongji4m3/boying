# SpringSecurity

Spring Security 采用 AOP，基于 Servlet 过滤器实现的安全框架。它提供了完善的认证机构和授权功能

# 权限系统

# 具体实现

# 流程

+ 访问一个api，会到自定义拦截器，
+ 用了一个缓存configAttributeMap存储拥有的所有资源，为空则查数据库。key为url，值为资源的id+name
+ 获取当前访问路径，例如：/category/listAll
+ 将configAttributeMap中所有url路径和/category/listAll进行匹配，匹配到则加入configAttributes中，类似："9:菜单管理",代表的是该api路径所需要的资源
+ 然后如果CollUtil.isEmpty(configAttributes)，代表没有对这个api设置资源，则不会拦截。
+ 如果有，则和用户拥有的资源：authentication.getAuthorities()逐个对比，都有才放行



## 用户登录

用户登录会把所有资源查询出来存入缓存中，查询sql：

```
select distinct admin_resource.*
        from admin_user_role
                 join admin_role on admin_user_role.role_id = admin_role.id
                 join admin_role_resource on admin_role.id = admin_role_resource.role_id
                 join admin_resource on admin_role_resource.resource_id = admin_resource.id
        where admin_user_role.user_id = #{userId}
          and admin_role.status = 1
          and admin_resource.status = 1;
```



```
//返回当前用户拥有的资源权限
        return resourceList.stream()
                .map(AdminResource -> new SimpleGrantedAuthority(AdminResource.getId() + ":" + AdminResource.getName()))
                .collect(Collectors.toList());
```



```
├───annotation
│       CacheException.java
│
├───aspect
│       RedisCacheAspect.java
│
├───component
│       DynamicAccessDecisionManager.java
│       DynamicSecurityFilter.java
│       DynamicSecurityMetadataSource.java
│       DynamicSecurityService.java
│       JwtAuthenticationTokenFilter.java
│       RestAuthenticationEntryPoint.java
│       RestfulAccessDeniedHandler.java
│
├───config
│       IgnoreUrlsConfig.java
│       RedisConfig.java
│       SecurityConfig.java
│
└───util
        JwtTokenUtil.java
```

登录核心类：config/SecurityConfig.java

调用了权限核心类：component/DynamicSecurityFilter

# 代码

如果没有携带token，则使用login方法

用户信息是通过缓存或数据库中查询，并封装成UserDetails对象

登录成功后将用户上下文信息存入SecurityContext中，并且生成Token返回。

```java
    @Override
    public String login(UsernameLoginParam param) {
        String username = param.getUsername();
        String password = param.getPassword();

        System.out.println(passwordEncoder.encode(password));

        String token = null;
        //密码需要客户端加密后传递,但是传递的仍然是明文
        UserDetails userDetails = loadUserByUsername(username);
        if (!passwordEncoder.matches(password, userDetails.getPassword())) {
            throw new BadCredentialsException("密码不正确");
        }
//            获取该用户的上下文信息
//            username和password被获得后封装到一个UsernamePasswordAuthenticationToken
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
//            围绕该用户建立安全上下文（security context）
        SecurityContextHolder.getContext().setAuthentication(authentication);
        token = jwtTokenUtil.generateToken(userDetails);
        return token;
    }

    @Override
    public UserDetails loadUserByUsername(String username) {
        BoyingUser user = getByUsername(username);
        return new BoyingUserDetails(user);
    }

    @Override
    public BoyingUser getByUsername(String username) {
        BoyingUser user = boyingUserCacheService.getUser(username);
        if (user != null) return user; //缓存里面有数据

        //根据用户名查询是否存在
        user = boyingUserMapper.selectByUsername(username);

        //不能给过于详细的错误提示！
        if (user == null) Asserts.fail("用户名或密码错误");

        //账号未启用
        if (user.getAdminDelete()) Asserts.fail("账号未启用,请联系管理员!");

        boyingUserCacheService.setUser(user);//将查询到的数据放入缓存中
        return user;
    }
```

## getCurrentUser()

```java
    @Override
    public BoyingUser getCurrentUser() {
//        获取之前登录存储的用户上下文信息
        //ThreadLocal
        SecurityContext ctx = SecurityContextHolder.getContext();
        Authentication auth = ctx.getAuthentication();
        BoyingUserDetails userDetails = (BoyingUserDetails) auth.getPrincipal();
        System.out.println(userDetails.getUser());
        return userDetails.getUser();
    }
```



## BoyingUserDetails

```java
/**
 * SpringSecurity需要的用户详情
 */
public class BoyingUserDetails implements UserDetails {
    private final BoyingUser user;

    public BoyingUserDetails(BoyingUser user) {
        this.user = user;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        //返回当前用户的角色
        return Arrays.asList(new SimpleGrantedAuthority("TEST"));
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUsername();
    }

    @Override
    public boolean isEnabled() {
        return user.getAdminDelete();
    }
}
```

## BoyingSecurityConfig

```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class BoyingSecurityConfig extends SecurityConfig {

    @Autowired
    private BoyingUserService boyingUserService;

    /**
     * 注解@Bean放在方法上，产生一个Bean并且交给Spring容器管理
     * 定义用户信息
     *
     * @return
     */
    @Bean
    public UserDetailsService userDetailsService() {
        //为UserDetailsService定义一个适用与boying-user组件的获取登录用户信息的方法
        return username -> boyingUserService.loadUserByUsername(username);
    }
    //不添加基于路径的动态权限控制
}
```

当有token时，过滤器会直接使用token进行登录：

```java
@Override
protected void doFilterInternal(HttpServletRequest request,
                                HttpServletResponse response,
                                FilterChain chain) throws ServletException, IOException
{
    //请求头有字段Authorization，并且以‘Bearer ’开头
    String authHeader = request.getHeader(this.tokenHeader);
    if (authHeader != null && authHeader.startsWith(this.tokenHead))
    {
        String authToken = authHeader.substring(this.tokenHead.length());// The part after "Bearer "
        String username = jwtTokenUtil.getUserNameFromToken(authToken);
        LOGGER.info("checking username:{}", username);
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null)
        {
            //SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限）
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);
            //验证用户名和是否已过期
            if (jwtTokenUtil.validateToken(authToken, userDetails))
            {
                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                LOGGER.info("authenticated user:{}", username);
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }
    }
    chain.doFilter(request, response);
}
```



## 用户信息

登录时，若缓存没有信息，则存入Redis中（用户名，用户信息）（手机号，用户信息）

```java
//boyingUserCacheService.setUser(user);//将查询到的数据放入缓存中

@Override
    public void setUser(BoyingUser user) {
        String key = REDIS_DATABASE + ":" + REDIS_KEY_USER + ":" + user.getUsername();
        String key2 = REDIS_DATABASE + ":" + REDIS_KEY_USER + ":" + user.getPhone();
//        设置两条,能通过手机号,用户名查到该用户
        redisService.set(key, user, REDIS_EXPIRE);
        redisService.set(key2, user, REDIS_EXPIRE);
    }
```

更新个人信息时，删除缓存

```java
    @Override
    public void delUser(int userId) {
//        确保全局不会redis缓存key混乱
        BoyingUser user = boyingUserMapper.selectByPrimaryKey(userId);
        if (user != null) {
            String key = REDIS_DATABASE + ":" + REDIS_KEY_USER + ":" + user.getUsername();
            String key2 = REDIS_DATABASE + ":" + REDIS_KEY_USER + ":" + user.getPhone();
            redisService.del(key);
            redisService.del(key2);
        }
    }
```





# JwtTokenUtil

用于生成和解析JWT token的工具类

```yml
jwt:
  tokenHeader: Authorization #JWT存储的请求头
  secret: boying-user-secret #JWT加解密使用的密钥
  expiration: 604800 #JWT的超期限时间(60*60*24*7) 7天过期
  tokenHead: 'Bearer '  #JWT负载中拿到开头
```

```java
public class JwtTokenUtil
{
    private static final String CLAIM_KEY_USERNAME = "sub";
    private static final String CLAIM_KEY_CREATED = "created";
    @Value("${jwt.secret}")
    private String secret;
    @Value("${jwt.expiration}")
    private Long expiration;
    @Value("${jwt.tokenHead}")
    private String tokenHead;
    
    /**
     * 根据登录用户信息生成token
     */
    public String generateToken(UserDetails userDetails)
    {
        Map<String, Object> claims = new HashMap<>();
        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());
        claims.put(CLAIM_KEY_CREATED, new Date());
        return generateToken(claims);
    }
    /**
     * 根据负责生成JWT的token
     */
    private String generateToken(Map<String, Object> claims)
    {
        return Jwts.builder()
                .setClaims(claims)
                .setExpiration(generateExpirationDate())
                .signWith(SignatureAlgorithm.HS512, secret)
                .compact();
    }
    /**
     * 生成token的过期时间
     */
    private Date generateExpirationDate()
    {
        return new Date(System.currentTimeMillis() + expiration * 1000);
    }
    
    
    /**
     * 从token中获取登录用户名
     */
    public String getUserNameFromToken(String token)
    {
        String username;
        try
        {
            Claims claims = getClaimsFromToken(token);
            username = claims.getSubject();
        }
        catch (Exception e)
        {
            username = null;
        }
        return username;
    }
    
    
    
    
    /**
     * 验证token是否还有效
     *
     * @param token       客户端传入的token
     * @param userDetails 从数据库中查询出来的用户信息
     */
    public boolean validateToken(String token, UserDetails userDetails)
    {
        String username = getUserNameFromToken(token);
        return username.equals(userDetails.getUsername()) && !isTokenExpired(token);
    }

    /**
     * 判断token是否已经失效
     */
    private boolean isTokenExpired(String token)
    {
        Date expiredDate = getExpiredDateFromToken(token);
        return expiredDate.before(new Date());
    }
}

```



# SecurityConfig

对SpringSecurity的配置的扩展，支持自定义白名单资源路径和查询用户逻辑，其他的所有类都是为它服务的

```java
public class SecurityConfig extends WebSecurityConfigurerAdapter
{
    //@Autowired(required=false)：表示忽略当前要注入的bean，如果有直接注入，没有跳过，不会报错。
    @Autowired(required = false)
    private DynamicSecurityService dynamicSecurityService;
    
    // 用于配置需要拦截的url路径、jwt过滤器及出异常后的处理器；
     @Override
    protected void configure(HttpSecurity httpSecurity) throws Exception
    {
        //不需要保护的资源路径允许访问
        for (String url : ignoreUrlsConfig().getUrls())
        {
            registry.antMatchers(url).permitAll();
        }
        
        //允许跨域请求的OPTIONS请求
        registry.antMatchers(HttpMethod.OPTIONS).permitAll();
        
        // 任何请求需要身份认证
        registry
                .accessDeniedHandler(restfulAccessDeniedHandler())// 无权限处理
                .authenticationEntryPoint(restAuthenticationEntryPoint())//未登录处理
                .addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);//权限拦截器JWT过滤器
    }
    @Bean
    public IgnoreUrlsConfig ignoreUrlsConfig()
    {
        return new IgnoreUrlsConfig();
    }
	/**
     * 当用户没有访问权限时,将调用该方法。是没有访问权限时的处理器，用于返回JSON格式的处理结果
     */
    @Bean
    public RestfulAccessDeniedHandler restfulAccessDeniedHandler()
    {
        return new RestfulAccessDeniedHandler();
    }
     /**
     * 当未登录或token失效时，返回JSON格式的结果
     *
     * @return
     */
    @Bean
    public RestAuthenticationEntryPoint restAuthenticationEntryPoint()
    {
        return new RestAuthenticationEntryPoint();
    }
    /**
     * 在用户名和密码校验前添加的过滤器，如果有jwt的token，会自行根据token信息进行登录。
     *
     * @return
     */
    @Bean
    public JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter()
    {
        return new JwtAuthenticationTokenFilter();
    }
    
    
    
    /**
     * 用于配置UserDetailsService及PasswordEncoder
     */
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception
    {
        //UserDetailsService:SpringSecurity定义的核心接口，用于根据用户名获取用户信息，需要自行实现
        auth.userDetailsService(userDetailsService())
                .passwordEncoder(passwordEncoder());
    }
    /**
     * SpringSecurity定义的用于对密码进行编码及比对的接口，目前使用的是BCryptPasswordEncoder
     */
    @Bean
    public PasswordEncoder passwordEncoder()
    {
        return new BCryptPasswordEncoder();
    }
}
```

## IgnoreUrlsConfig

处理SecurityConfig中的白名单，用于不需要保护的资源路径允许访问

```yml
secure:
  ignored:
    urls: #安全路径白名单
      - /swagger-ui.html
      - /user/**
      - /home/**
```

```java
/**
 * 用于配置白名单资源路径
 * 将大量的参数配置在 application.yml 文件中，
 * 通过 @ConfigurationProperties 注解，我们可以方便的获取这些参数值
 */
@Getter
@Setter
@ConfigurationProperties(prefix = "secure.ignored")
public class IgnoreUrlsConfig
{

    private List<String> urls = new ArrayList<>();

}
```

## RestfulAccessDeniedHandler

```java
/**
 * 处理SecurityConfig中没有权限访问时自定义返回结果，返回403相关信息
 * 自定义返回结果：没有权限访问时
 * 返回403相关信息
 */
public class RestfulAccessDeniedHandler implements AccessDeniedHandler
{
    @Override
    public void handle(HttpServletRequest request,
                       HttpServletResponse response,
                       AccessDeniedException e) throws IOException, ServletException
    {     response.getWriter().println(JSONUtil.parse(CommonResult.forbidden(e.getMessage())));
        response.getWriter().flush();
    }
}
```

## RestAuthenticationEntryPoint

```java
/**
 * 自定义返回结果：未登录或登录过期
 * 即返回401相关信息
 */
public class RestAuthenticationEntryPoint implements AuthenticationEntryPoint
{
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException
    {
        response.setHeader("Access-Control-Allow-Origin", "*");
        response.setHeader("Cache-Control", "no-cache");
        response.setCharacterEncoding("UTF-8");
        response.setContentType("application/json");
        response.getWriter().println(JSONUtil.parse(CommonResult.unauthorized(authException.getMessage())));
        response.getWriter().flush();
    }
}
```

## JwtAuthenticationTokenFilter

处理SecurityConfig，在用户名和密码校验前添加的过滤器，如果请求中有jwt的token且有效，会取出token中的用户名，然后调用SpringSecurity的API进行登录操作。

```java
/**
 * JWT登录授权过滤器
 
  tokenHeader: Authorization #JWT存储的请求头
  tokenHead: 'Bearer '  #JWT负载中拿到开头
 */
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter
{
 
    /**
     * SpringSecurity定义的核心接口，用于根据用户名获取用户信息
     */
    @Autowired
    private UserDetailsService userDetailsService;
    @Autowired
    private JwtTokenUtil jwtTokenUtil;
    @Value("${jwt.tokenHeader}")
    private String tokenHeader;
    @Value("${jwt.tokenHead}")
    private String tokenHead;

     @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException
    {
        //请求头有字段Authorization，并且以‘Bearer ’开头
        String authHeader = request.getHeader(this.tokenHeader);
        if (authHeader != null && authHeader.startsWith(this.tokenHead))
        {
            String authToken = authHeader.substring(this.tokenHead.length());// The part after "Bearer "
            String username = jwtTokenUtil.getUserNameFromToken(authToken);
            LOGGER.info("checking username:{}", username);
            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null)
            {
                //SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限）
                //这里首先从缓存中获取用户信息和用户权限
                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);
                //验证用户名和是否已过期
                if (jwtTokenUtil.validateToken(authToken, userDetails))
                {
                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    LOGGER.info("authenticated user:{}", username);
                    /*
                    SecurityContextHolder使用了ThreadLocal机制来保存每个使用者的安全上下文。
                    这意味着，只要针对某个使用者的逻辑执行都是在同一个线程中进行，即使不在各个方法之间以参数的形式传递其安全上下文，
                    各个方法也能通过SecurityContextHolder工具获取到该安全上下文。只要在处理完当前使用者的请求之后注意清除ThreadLocal中的安全上下文
                     */
                    SecurityContextHolder.getContext().setAuthentication(authentication);
                }
            }
        }
        chain.doFilter(request, response);
    }
}
```



## BoyingSecurityConfig

实现了对SecurityConfig的扩展，获取用户信息和用户拥有的权限

```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class BoyingSecurityConfig extends SecurityConfig
{

    @Autowired
    private UmsAdminService adminService;
    @Autowired
    private UmsResourceService resourceService;

    //实现security模块的该方法，根据用户名获取用户信息
    @Bean
    public UserDetailsService userDetailsService()
    {
        //获取登录用户信息
        return username -> adminService.loadUserByUsername(username);
        /*
        @Override
        public UserDetails loadUserByUsername(String username)
        {
            //获取用户信息
            AdminUser AdminUser = getAdminByUsername(username);
            if (AdminUser != null)
            {
                List<AdminResource> resourceList = getResourceList(AdminUser.getId());
                return new AdminUserDetails(AdminUser, resourceList);
            }
            throw new UsernameNotFoundException("用户名或密码错误");
        }
        */
    }

    //    加载所有的资源 资源路径url,资源路径值(自定义为了 id:name )
    @Bean
    public DynamicSecurityService dynamicSecurityService()
    {
        return new DynamicSecurityService()
        {
            @Override
            public Map<String, ConfigAttribute> loadDataSource()
            {
                Map<String, ConfigAttribute> map = new ConcurrentHashMap<>();
                List<AdminResource> resourceList = resourceService.listAll();
                for (AdminResource resource : resourceList)
                {
                    map.put(resource.getUrl(), new org.springframework.security.access.SecurityConfig(resource.getId() + ":" + resource.getName()));
                }
                return map;
            }
        };
    }
}
```

## UserDetails

SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限）

```java
public interface UserDetails extends Serializable 
{
    Collection<? extends GrantedAuthority> getAuthorities();

    String getPassword();

    String getUsername();

    boolean isEnabled();
}
```

## AdminUserDetails

```java
/**
 * SpringSecurity需要的用户详情
 */
public class AdminUserDetails implements UserDetails
{
    private final AdminUser adminUser;
    private final List<AdminResource> resourceList;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities()
    {
        //返回当前用户拥有的资源权限
        return resourceList.stream()
                .map(AdminResource -> new SimpleGrantedAuthority(AdminResource.getId() + ":" + AdminResource.getName()))
                .collect(Collectors.toList());
    }
    
     @Override
    public String getPassword()
    {
        return adminUser.getPassword();
    }

    @Override
    public String getUsername()
    {
        return adminUser.getUsername();
    }

    @Override
    public boolean isEnabled()
    {
        return adminUser.getStatus();
    }

}
```



# 基于路径的动态权限控制

当有动态权限业务类时在FilterSecurityInterceptor过滤器前添加我们的动态权限过滤器。这里在创建动态权限相关对象时，还使用了@ConditionalOnBean这个注解，当没有动态权限业务类时就不会创建动态权限相关对象，实现了有动态权限控制和没有这两种情况的兼容。

例如admin中有DynamicSecurityService这个Bean对象，则所有的动态权限控制可用

```java
public class SecurityConfig extends WebSecurityConfigurerAdapter
{
    @Autowired(required = false)
    private DynamicSecurityService dynamicSecurityService;
    
     @Override
    protected void configure(HttpSecurity httpSecurity) throws Exception
    {
        //有动态权限配置时添加动态权限校验过滤器
        if (dynamicSecurityService != null)
        {
            //在指定的beforeFilter之前加入filter
            registry.and().addFilterBefore(dynamicSecurityFilter(), 	FilterSecurityInterceptor.class);
        }
    }
    

    
    @ConditionalOnBean(name = "dynamicSecurityService")
    @Bean
    public DynamicSecurityFilter dynamicSecurityFilter()
    {
        return new DynamicSecurityFilter();
    }
    
    //使用了@ConditionalOnBean这个注解,当没有动态权限业务类时就不会创建动态权限相关对象，实现了有动态权限控制和没有这两种情况的兼容。
    @ConditionalOnBean(name = "dynamicSecurityService")
    @Bean
    public DynamicAccessDecisionManager dynamicAccessDecisionManager()
    {
        return new DynamicAccessDecisionManager();
    }


    @ConditionalOnBean(name = "dynamicSecurityService")
    @Bean
    public DynamicSecurityFilter dynamicSecurityFilter()
    {
        return new DynamicSecurityFilter();
    }

    @ConditionalOnBean(name = "dynamicSecurityService")
    @Bean
    public DynamicSecurityMetadataSource dynamicSecurityMetadataSource()
    {
        return new DynamicSecurityMetadataSource();
    }
}
```

## DynamicSecurityFilter
动态权限过滤器，用于实现基于路径的动态权限过滤。

首先我们需要创建一个过滤器，用于实现动态权限控制，这里需要注意的是`doFilter`方法，对于OPTIONS请求直接放行，否则前端调用会出现跨域问题。对于配置在`IgnoreUrlsConfig`中的白名单路径我也需要直接放行，所有的鉴权操作都会在`super.beforeInvocation(fi)`中进行。

```java
/**
 * 动态权限过滤器，用于实现基于路径的动态权限过滤
 */
public class DynamicSecurityFilter extends AbstractSecurityInterceptor implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        FilterInvocation fi = new FilterInvocation(servletRequest, servletResponse, filterChain);
        //OPTIONS请求直接放行
        if(request.getMethod().equals(HttpMethod.OPTIONS.toString())){
            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
            return;
        }
        //白名单请求直接放行
        PathMatcher pathMatcher = new AntPathMatcher();
        for (String path : ignoreUrlsConfig.getUrls()) {
            if(pathMatcher.match(path,request.getRequestURI())){
                fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
                return;
            }
        }
        //此处会调用AccessDecisionManager中的decide方法进行鉴权操作
        InterceptorStatusToken token = super.beforeInvocation(fi);
        try {
            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
        } finally {
            super.afterInvocation(token, null);
        }
    }
}
```

## DynamicSecurityMetadataSource
自己实现SecurityMetadataSource接口的getAttributes方法，用于获取当前访问路径所需资源。

```java
/**
 * 动态权限数据源，用于获取动态权限规则
 */
public class DynamicSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {
	//后台资源规则被缓存在了一个Map对象之中
    private static Map<String, ConfigAttribute> configAttributeMap = null;
    
    //动态权限相关业务类，自定义的一个动态权限业务接口，其主要用于加载所有的后台资源规则。
    @Autowired
    private DynamicSecurityService dynamicSecurityService;

    @PostConstruct
    public void loadDataSource() {
        configAttributeMap = dynamicSecurityService.loadDataSource();
    }

    //所以当后台资源发生变化时，我们需要清空缓存的数据
    public void clearDataSource() {
        configAttributeMap.clear();
        configAttributeMap = null;
    }

    @Override
    public Collection<ConfigAttribute> getAttributes(Object o) throws IllegalArgumentException {
        if (configAttributeMap == null) this.loadDataSource();
        List<ConfigAttribute>  configAttributes = new ArrayList<>();
        //获取当前访问的路径
        String url = ((FilterInvocation) o).getRequestUrl();
        String path = URLUtil.getPath(url);
        PathMatcher pathMatcher = new AntPathMatcher();
        Iterator<String> iterator = configAttributeMap.keySet().iterator();
        //获取访问该路径所需资源
        while (iterator.hasNext()) {
            String pattern = iterator.next();
            if (pathMatcher.match(pattern, path)) {
                configAttributes.add(configAttributeMap.get(pattern));
            }
        }
        // 未设置操作请求权限，返回空集合
        return configAttributes;
    }
}
```

## DynamicAccessDecisionManager

实现AccessDecisionManager接口来实现权限校验，对于没有配置资源的接口我们直接允许访问，对于配置了资源的接口，我们把访问所需资源和用户拥有的资源进行比对，如果匹配则允许访问。

```java
/**
 * 动态权限决策管理器，用于判断用户是否有访问权限
 */
public class DynamicAccessDecisionManager implements AccessDecisionManager {

    @Override
    public void decide(Authentication authentication, Object object,
                       Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException {
        // 当接口未被配置资源时直接放行
        if (CollUtil.isEmpty(configAttributes)) {
            return;
        }
        Iterator<ConfigAttribute> iterator = configAttributes.iterator();
        while (iterator.hasNext()) {
            ConfigAttribute configAttribute = iterator.next();
            //将访问所需资源或用户拥有资源进行比对
            String needAuthority = configAttribute.getAttribute();
            for (GrantedAuthority grantedAuthority : authentication.getAuthorities()) {
                if (needAuthority.trim().equals(grantedAuthority.getAuthority())) {
                    return;
                }
            }
        }
        throw new AccessDeniedException("抱歉，您没有访问权限");
    }
}
```

## DynamicSecurityService

动态权限相关业务类，自定义的一个动态权限业务接口，其主要用于加载所有的后台资源规则。

```java
/**
 * 动态权限相关业务类
 */
public interface DynamicSecurityService {
    /**
     * 加载资源ANT通配符和资源对应MAP
     */
    Map<String, ConfigAttribute> loadDataSource();
}
```



## BoyingSecurityConfig

此类是admin中的类

当有动态权限业务类时在FilterSecurityInterceptor过滤器前添加我们的动态权限过滤器。这里在创建动态权限相关对象时，还使用了@ConditionalOnBean这个注解，当没有动态权限业务类时就不会创建动态权限相关对象，实现了有动态权限控制和没有这两种情况的兼容。

```java
public class BoyingSecurityConfig extends SecurityConfig
{
    //    加载所有的资源 资源路径url,资源路径值(自定义为了 id:name )
    @Bean
    public DynamicSecurityService dynamicSecurityService()
    {
        return new DynamicSecurityService()
        {
            @Override
            public Map<String, ConfigAttribute> loadDataSource()
            {
                Map<String, ConfigAttribute> map = new ConcurrentHashMap<>();
                List<AdminResource> resourceList = resourceService.listAll();
                for (AdminResource resource : resourceList)
                {
                    map.put(resource.getUrl(), new org.springframework.security.access.SecurityConfig(resource.getId() + ":" + resource.getName()));
                }
                return map;
            }
        };
    }
}
```

## AdminUserDetails

```java
public class AdminUserDetails implements UserDetails
{
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities()
    {
        //返回当前用户拥有的资源权限
        return resourceList.stream()
                .map(AdminResource -> new SimpleGrantedAuthority(AdminResource.getId() + ":" + AdminResource.getName()))
                .collect(Collectors.toList());
    }
}
```



# AOP优化

给获取用户信息和获取用户的资源信息这两个操作添加缓存操作，当我们修改用户信息和资源信息时都需要删除缓存中的数据

## RedisCacheAspect

```java
/**
 * Redis缓存切面，防止Redis宕机影响正常业务逻辑
 * 定义一个切面，在相关缓存业务类上面应用，在它的环绕通知中直接处理掉异常，保障后续操作能执行。
 * 因为作为缓存，我们所希望的是，如果Redis宕机了，我们的业务逻辑不会有影响。
 * 要保证缓存业务类中的方法执行不影响正常的业务逻辑，就需要在所有方法中添加`try catch`逻辑。
 * 使用AOP，我们可以在一个地方写上`try catch`逻辑，然后应用到所有方法上去。
 */
@Aspect
@Component
@Order(2)
public class RedisCacheAspect
{
    private static final Logger LOGGER = LoggerFactory.getLogger(RedisCacheAspect.class);

    @Pointcut("execution(public * com.tongji.boying.service.*CacheService.*(..))")
    public void cacheAspect()
    {
    }

    @Around("cacheAspect()")
    public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable
    {
        Signature signature = joinPoint.getSignature();
        MethodSignature methodSignature = (MethodSignature) signature;
        Method method = methodSignature.getMethod();
        Object result = null;
        try
        {
            result = joinPoint.proceed();
        }
        catch (Throwable throwable)
        {
            //有CacheException注解的方法需要抛出异常
            if (method.isAnnotationPresent(CacheException.class))
            {
                throw throwable;
            }
            else
            {
                LOGGER.error(throwable.getMessage());
            }
        }
        return result;
    }
}
```

## CacheException

自定义注解，有该注解的缓存方法会抛出异常。例如验证码存储，如果我们的Redis宕机了，我们的验证码存储接口需要的是报错，而不是返回执行成功。

```java
/**
 * 自定义注解，有该注解的缓存方法会抛出异常
 */
@Documented
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface CacheException
{
}
```

## RedisConfig

```java
/**
 * Redis配置类
 */
@EnableCaching
@Configuration
public class RedisConfig extends BaseRedisConfig
{

}
```

# 前后端分离跨域问题

CORS全称Cross-Origin Resource Sharing，意为跨域资源共享。当一个资源去访问另一个不同域名或者同域名不同端口的资源时，就会发出跨域请求。如果此时另一个资源不允许其进行跨域资源访问，那么访问的那个资源就会遇到跨域问题。

## 添加GlobalCorsConfig配置文件来允许跨域访问。

```java
/**
 * 全局跨域配置
 */
@Configuration
public class GlobalCorsConfig {

    /**
     * 允许跨域调用的过滤器
     */
    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        //允许所有域名进行跨域调用
        config.addAllowedOrigin("*");
        //允许跨越发送cookie
        config.setAllowCredentials(true);
        //放行全部原始头信息
        config.addAllowedHeader("*");
        //允许所有请求方法跨域调用
        config.addAllowedMethod("*");
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return new CorsFilter(source);
    }
}
```

此时发现，需要登录认证的/admin/info接口的OPTIONS请求无法通过认证，那是因为复杂的跨越请求需要先进行一次OPTIONS请求进行预检，我们的应用整合了SpringSecurity，对OPTIONS请求并没有放开登录认证。

## 设置SpringSecurity允许OPTIONS请求访问

在SecurityConfig类的configure(HttpSecurity httpSecurity)方法中添加如下代码。

```java
.antMatchers(HttpMethod.OPTIONS)//跨域请求会先进行一次options请求
.permitAll()
```

## 一次完整的跨域请求

### 先发起一次OPTIONS请求进行预检

**请求头信息**

```text
Access-Control-Request-Headers: content-type
Access-Control-Request-Method: POST
Origin: http://localhost:8090
Referer: http://localhost:8090/
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36
```

**响应头信息**

```text
Access-Control-Allow-Credentials: true
Access-Control-Allow-Headers: content-type
Access-Control-Allow-Methods: POST
Access-Control-Allow-Origin: http://localhost:8090
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Content-Length: 0
Date: Sat, 27 Jul 2019 13:40:32 GMT
Expires: 0
Pragma: no-cache
Vary: Origin, Access-Control-Request-Method, Access-Control-Request-Headers
X-Content-Type-Options: nosniff
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
```

- 请求成功返回状态码为200

### 发起真实的跨域请求





# 背景知识

## 权限系统

权限系统就是：明确操作人员可在平台内能做什么。即什么样的人，可以做什么样的事，这并不难理解，我们的用户是所有可以登录该平台的人员。

“用户管理”、“角色管理”、“权限管理”

RBAC（Role-Based Access Control）即：权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。

用户与角色一一对应，一个用户对应一个角色；同一个角色可对应多个后台操作页面

RBAC结构可通过“角色”搭建用户与权限之间的关系，可在创建角色时绑定相应权限，再匹配到用户，可提高整体的效率以及稳定性。

## 认证

用户认证通过后，将用户信息保存在会话中，如token等。基于JWT令牌，会话通过token保存。认证是保护用户身份的合法性。

## 授权

更细粒度的对隐私数据进行划分。授权是用户认证通过根据用户的权限来控制用户访问资源的过程。



## RBAC

“用户-角色-权限”管理是 **“访问控制”** 的一种实现方式，更为专业的叫法为 **RBAC**（Role-Based Access Control），即基于角色的权限访问控制。

权限的三种粒度：**菜单权限、操作/功能权限、数据权限**。

## 用户管理

- **用户信息：** 显示用户的基本信息（昵称、联系方式、角色、部门等）
- **用户操作：** 为用户分配角色（多对多）、组织架构（多对多），删除用户
- **用户黑白名单：** 对特殊用户进行特别控制

## 角色管理

- **角色信息：** 显示角色的基本信息（名称、权限等）
- **角色操作：** 根据需要增删角色、为角色分配权限（多对多，按不同粒度分配，并实现权限的互斥性检验）

## 权限管理

权限一般有如下三种粒度：

- **菜单权限：** 访问某一菜单（页面、路由）的权限
- **操作/功能权限：** 进行某一操作或使用某一功能的权限（如删除用户的权限）
- **数据权限：** 访问某种数据（表、字段）的权限，或对可操作数据量的控制

## 技术要点

- 用户、角色、权限、组织架构表结构设计
- 用户身份验证、授权、会话管理，用户信息的加密存储
- 不同粒度权限的具体实现



# 权限管理

权限管理在后端项目中主要体现在对接口访问权限的控制，在前端项目中主要体现在对菜单访问权限的控制

如何结合Vue来实现菜单的动态权限控制。

## 菜单管理

可以实现对后台管理系统左侧菜单的管理，支持更换图标、更换名称、控制菜单显示和排序（控制其隐藏显示及更换图片名称和排序，目前仅支持二级菜单）

菜单管理用于控制前端菜单的显示和隐藏

- 查看菜单列表，可以控制隐藏显示及删除；
- 添加及编辑菜单，可以更改菜单的基本属性，不过只能添加前端项目`路由中定义`的菜单，并且`前端名称`要与前端项目中定义的`路由名称`一致；
- 菜单排序，给菜单设置排序后，菜单将按照设置的排序降序进行显示。

## 资源管理

资源管理用来控制后端接口的访问权限。

后台资源表，用于控制后台用户可以访问的接口，使用了Ant路径的匹配规则，可以使用通配符定义一系列接口的权限。

实现了基于访问路径的后台动态权限控制，控制的权限可以精确到接口级别

所谓资源就是后台的接口，可以是单个接口，也可以是一系列接口的集合。这里我们使用了基于Ant的路径匹配，当后台用户访问某个接口时，如果这个后台用户分配了该资源就可以访问，否则无法访问。默认情况下，如果你没有对某个接口配置资源，则该资源直接允许访问。

例子：将订单相关菜单开放给商品管理员，但是并没有给他分配订单相关的资源；能进入那个菜单，但是由于没有给商品管理员分配订单模块相关后台资源，所以当商品管理员访问订单模块时会提示没有相关权限。

- 查看资源列表，目前的资源是按控制器级别配置的，即一个控制器中所有的接口定义为一个资源，也可以配置到接口级别；
- 添加及编辑资源，这里我们添加了一个资源分类的概念，便于以后的资源分配；

## 角色管理

可以自定义角色，并为角色分配菜单和资源；

用于对后台用户角色进行管理，我们可以给角色分配指定的菜单和资源，这样被分配了角色的后台用户就可以访问这些菜单和资源了。

## 后台用户管理

可以对后台用户进行管理并分配角色，支持分配多个角色。

用于对后台用户进行管理，直接修改信息（包括修改密码）及分配角色





# config

## AdminUserDetails

SpringSecurity需要的用户详情

```java
public class AdminUserDetails implements UserDetails
{
    private final AdminUser adminUser;
    private final List<AdminResource> resourceList;

    public AdminUserDetails(AdminUser AdminUser, List<AdminResource> resourceList)
    {
        this.adminUser = AdminUser;
        this.resourceList = resourceList;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities()
    {
        //返回当前用户拥有的资源权限
        return resourceList.stream()
                .map(AdminResource -> new SimpleGrantedAuthority(AdminResource.getId() + ":" + AdminResource.getName()))
                .collect(Collectors.toList());
    }
    
    //根据status标识该账号是否可用
     @Override
    public boolean isEnabled()
    {
        return adminUser.getStatus();
    }
}
```

## BoyingSecurityConfig

### userDetailsService()

根据用户名获取登录用户信息

### dynamicSecurityService()

要实现动态路径控制则必须实现该方法,注入`Bean`,目的是加载所有的资源,这通过一个Map实现,存储资源路径url,资源路径值(自定义为了 id:name )



## GlobalCorsConfig

全局跨域相关配置

## MyBatisConfig

MyBatis相关配置，控制dao或者mapper文件扫描位置

## SwaggerConfig

对boying-common的swagger相关组件进行自定义配置。Swagger API文档相关配置，主要是api扫描位置以及标题等



# 优化

因为每次访问接口进行权限校验时都会从数据库中去查询用户信息。最近对这个问题进行了优化，通过Redis+AOP解决了该问题，下面来讲下我的优化思路。

在`mall-security`模块中有一个过滤器，当用户登录后，请求会带着token经过这个过滤器。这个过滤器会根据用户携带的token进行类似免密登录的操作，其中有一步会从数据库中查询登录用户信息，下面是这个过滤器类的代码。



```java
/**
 * JWT登录授权过滤器
 */
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException {
        String authHeader = request.getHeader(this.tokenHeader);
        if (authHeader != null && authHeader.startsWith(this.tokenHead)) {
            String authToken = authHeader.substring(this.tokenHead.length());// The part after "Bearer "
            String username = jwtTokenUtil.getUserNameFromToken(authToken);
            LOGGER.info("checking username:{}", username);
            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                //此处会从数据库中获取登录用户信息
                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);
                if (jwtTokenUtil.validateToken(authToken, userDetails)) {
                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    LOGGER.info("authenticated user:{}", username);
                    SecurityContextHolder.getContext().setAuthentication(authentication);
                }
            }
        }
        chain.doFilter(request, response);
    }
}
```

当我们登录后访问任意接口时，控制台会打印如下日志，表示会从数据库中查询用户信息和用户所拥有的资源信息，每次访问接口都触发这种操作，有的时候会带来一定的性能问题。

对于上面的问题，最容易想到的就是把用户信息和用户资源信息存入到Redis中去，避免频繁查询数据库

首先我们需要对Spring Security中获取用户信息的方法添加缓存

主要是获取用户信息和获取用户的资源信息这两个操作，接下来我们需要给这两个操作添加缓存操作，这里使用的是RedisTemple的操作方式。当查询数据时，先去Redis缓存中查询，如果Redis中没有，再从数据库查询，查询到以后在把数据存储到Redis中去。

```java
	@Override
    public List<UmsResource> getResourceList(Long adminId) {
        //先从缓存中获取数据
        List<UmsResource> resourceList = adminCacheService.getResourceList(adminId);
        if(CollUtil.isNotEmpty(resourceList)){
            return  resourceList;
        }
        //缓存中没有从数据库中获取
        resourceList = adminRoleRelationDao.getResourceList(adminId);
        if(CollUtil.isNotEmpty(resourceList)){
            //将数据库中的数据存入缓存中
            adminCacheService.setResourceList(adminId,resourceList);
        }
        return resourceList;
    }
```

因为作为缓存，我们所希望的是，如果Redis宕机了，我们的业务逻辑不会有影响，而使用Spring Cache来实现的话，当Redis宕机以后，用户的登录等种种操作就会都无法进行了。

由于我们把用户信息和用户资源信息都缓存到了Redis中，所以当我们修改用户信息和资源信息时都需要删除缓存中的数据，具体什么时候删除，查看缓存业务类的注释即可。

经过上面的一系列优化之后，性能问题解决了。但是引入新的技术之后，新的问题也会产生，比如说当Redis宕机以后，我们直接就无法登录了，下面我们使用AOP来解决这个问题。

## 使用AOP处理缓存操作异常

要保证缓存业务类中的方法执行不影响正常的业务逻辑，就需要在所有方法中添加`try catch`逻辑。使用AOP，我们可以在一个地方写上`try catch`逻辑，然后应用到所有方法上去。试想下，我们如果又多了几个缓存业务类，只要配置下切面即可，这波操作多方便！

## RedisCacheAspect

首先我们先定义一个切面，在相关缓存业务类上面应用，在它的环绕通知中直接处理掉异常，保障后续操作能执行。

```java
/**
 * Redis缓存切面，防止Redis宕机影响正常业务逻辑
 */
@Aspect
@Component
@Order(2)
public class RedisCacheAspect {
    private static Logger LOGGER = LoggerFactory.getLogger(RedisCacheAspect.class);

    @Pointcut("execution(public * com.macro.mall.portal.service.*CacheService.*(..)) || execution(public * com.macro.mall.service.*CacheService.*(..))")
    public void cacheAspect() {
    }

    @Around("cacheAspect()")
    public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable {
        Object result = null;
        try {
            result = joinPoint.proceed();
        } catch (Throwable throwable) {
            LOGGER.error(throwable.getMessage());
        }
        return result;
    }

}
```

# 简历简介

该项目使用SpringSecurity实现后台用户的认证和授权，权限管理主要包括以下功能：

- 菜单管理：用于控制前端菜单的显示和隐藏，支持更换图标、更换名称、排序等。
- 资源管理：用来控制后端接口的访问权限，控制的权限可以精确到接口级别。
- 角色管理：可以自定义角色，并为角色分配菜单和资源。
- 后台用户管理：可以对后台用户进行管理并分配角色，支持分配多个角色。