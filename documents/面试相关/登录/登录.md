# Session和Cookie

## 背景

+ HTTP是一种无状态协议，即服务器不保留与客户交易时的任何状态。
+ 上一次的请求对这次的请求没有任何影响，服务端也不会对客户端上一次的请求进行任何记录处理。
+ 用户登录后，切换到其他界面，进行操作，服务器端是无法判断是哪个用户登录的。 每次进行页面跳转的时候，得重新登录。
+ 既然HTTP协议是无状态的，不会记录用户信息，那么怎么样才能让HTTP协议记录用户信息呢？换句话说，服务器怎么判断发来HTTP请求的是哪个用户？
+ 于是，两种用于保持HTTP状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。
+ cookie和session都是用来跟踪浏览器用户身份的会话方式。

## 区别



+ cookie数据保存在客户端，session数据保存在服务端。
+ cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，如果主要考虑到安全应当使用session
+ session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE
+ 将登陆信息等重要信息存放为SESSION；其他信息如果需要保留，可以放在COOKIE中

## Cookie

+ cookie 机制采用的是在客户端保持状态的方案。
+ Cookie 是服务器生成的，但是发送给客户端，并且由客户端来保存。每次请求加上 Cookie就行了。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

## Session

+ 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 Session。客户端浏览器再次访问时，只需要从该 Session 中查找该客户的状态就可以了。
+ Session 保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为 Session 需要使用Cookie 作为识别标志。HTTP协议是无状态的，Session 不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为 JSESSIONID 的 Cookie，它的值为该 Session 的 id（即放在HTTP响应报文头部信息里的Set-Cookie）。Session依据该 Cookie 来识别是否为同一用户。

## Cookie的工作原理

+ 浏览器端第一次发送请求到服务器端
+ 服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端
+ 浏览器端再次访问服务器端时会携带服务器端创建的Cookie
+ 服务器端通过Cookie中携带的数据区分不同的用户
+ sessionid是服务器和客户端连接时候随机分配的，如果浏览器使用的是cookie，那么所有数据都保存在浏览器端，比如你登陆以后，服务器设置了cookie用户名，那么当你再次请求服务器的时候，浏览器会将用户名一块发送给服务器，这些变量有一定的特殊标记。服务器会解释为cookie变量，所以只要不关闭浏览器，那么cookie变量一直是有效的，所以能够保证长时间不掉线。
+ 如果你能够截获某个用户的cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用cookie被攻击的可能性比较大。如果cookie设置了有效值，那么cookie会保存到客户端的硬盘上，下次在访问网站的时候，浏览器先检查有没有cookie，如果有的话，读取cookie，然后发送给服务器。

## Session的工作原理

+ 浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为session对象的ID），然后将该Cookie发送至浏览器端
+ 浏览器端发送第N次请求到服务器端，浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象
+ 服务器端根据name为JSESSIONID的Cookie的value(sessionId)去查询Session对象，从而区分不同用户。
+ 简单的说，当你登陆一个网站的时候，如果web服务器端使用的是session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登陆或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造。

session的常见实现形式是会话cookie（session cookie），即未设置过期时间的cookie，这个cookie的默认生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。实现机制是当用户发起一个请求的时候，服务器会检查该请求中是否包含sessionid，如果未包含，则系统会创造一个名为JSESSIONID的输出 cookie返回给浏览器(只放入内存，并不存在硬盘中)，并将其以HashTable的形式写到服务器的内存里面；当已经包含sessionid是，服务端会检查找到与该session相匹配的信息，如果存在则直接使用该sessionid，若不存在则重新生成新的 session。这里需要注意的是session始终是有服务端创建的，并非浏览器自己生成的。但是浏览器的cookie被禁止后session就需要用get方法的URL重写的机制或使用POST方法提交隐藏表单的形式来实现。

# JWT

JWT是JSON WEB TOKEN的缩写，是一种可以安全传输的的JSON对象， 是一种浏览器与服务器之间的一种身份认证机制。可实现无状态、分布式的Web应用授权。

特点是

- 安全：签名token，无法伪造。
- 无状态：不依赖服务端，不用维持会话。服务器就不保存任何 session 数据，服务器变成无状态。存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性

采用原始的token机制，放在`HTTP`请求的`header`中，`header`格式：

```xml
Authorization: Bearer <token>
```



JWT是一个含签名并携带用户相关信息的加密串，页面请求校验登录接口时，请求头中携带JWT串到后端服务，后端通过签名加密串匹配校验，保证信息未被篡改。校验通过则认为是可靠的请求，将正常返回数据。

在身份验证中，当用户使用其凭据成功登录时，将返回JSON Web Token（即：JWT）。由于令牌是凭证，因此必须非常小心以防止出现安全问题。一般情况下，不应将令牌保留的时间超过要求。理论上超时时间越短越好。

每当用户想要访问受保护的路由或资源时，用户代理应该使用Bearer模式发送JWT

在某些情况下，这可以作为无状态授权机制。服务器的受保护路由将检查Authorization header中的有效JWT ，如果有效，则允许用户访问受保护资源。如果JWT包含必要的数据，则可以减少查询数据库或缓存信息。



此时 signature字段就是关键了，能被解密出明文的，只有header和payload
假如黑客/中间人串改了payload，那么服务器可以通过signature去验证是否被篡改过。
在服务端在执行一次 signature = 加密算法(header + “.” + payload, 密钥);, 然后对比 signature 是否一致，如果一致则说明没有被篡改。
所以为什么说服务器的密钥不能被泄漏。
如果泄漏，将存在以下风险:
客户端可以自行签发 token
黑客/中间人可以肆意篡改 token



基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。

## JWT token的格式

**header.payload.signature**

- header中用于存放签名的生成算法、token的类型{"alg": "HS512","typ": "JWT"}
- payload中用于存放用户名、token的生成时间和过期时间
- signature：签名是把header和payload（载荷）对应的json结构进行base64 url编码之后得到的两个串，用英文句点号拼接起来，然后根据header里面alg指定的签名算法生成出来的。JWT 的最后一部分是 Signature ，这部分内容有三个部分，先是用 Base64 编码的 header 和 payload ，再用加密算法加密一下，加密的时候要放进去一个 Secret ，这个相当于是一个密码，这个密码秘密地存储在服务端。

## JWT实现认证和授权的原理

1. 客户端使用用户名跟密码请求登录；
2. 服务端收到请求，去验证用户名与密码；
3. 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端；
4. 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里；
5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token（在http的header中添加一个叫Authorization的头，值为JWT的token）；
6. 服务端收到请求，通过对Authorization头中信息的解码及数字签名校验来获取其中的用户信息，从而实现认证和授权，进一步解析 Token 内容，获知用户身份。如果验证成功，就向客户端返回请求的数据。



服务端仅验证 Token 合法性，校验 Token 合法性需要确认几件事情：

- Token 有没有过期
- 是不是自己签发的

**区别** 

+ session 存储在服务端占用服务器资源，而 JWT 存储在客户端
+ session 存储在 Cookie 中，存在伪造跨站请求伪造攻击的风险
+ session 只存在一台服务器上，那么下次请求就必须请求这台服务器，不利于分布式应用 
+ 存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性

**优点**

1. 解决跨域问题：这种基于Token的访问策略可以克服cookies的跨域问题。
2. 服务端无状态可以横向扩展，Token可完成认证，无需存储Session。
3. 系统解耦，Token携带所有的用户信息，无需绑定一个特定的认证方案，只需要知道加密的方法和密钥就可以进行加密解密，有利于解耦。
4. 防止跨站点脚本攻击，没有cookie技术，无需考虑跨站请求的安全问题。

## 优点

Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输. 
无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息. 
更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可. 
去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可. 
更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。 
CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。 
性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多. 
不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理. 
基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.

# 登录功能

## 无权限控制

前端配置了挂载路由导航守卫，如果请求的不是登录页并且sessionStorage中没有token，则跳转登录页面

```javascript
//挂载路由导航守卫
router.beforeEach((to, from, next) => {
  if (to.path === '/login' || to.path === '/register') {
    window.sessionStorage.clear();
    return next();
  }
  if (to.path === '/home') {
    return next();
  }
  //获取token
  const tokenStr = window.sessionStorage.getItem('token');
  //无token强制跳转到登录页面
  if (!tokenStr) return next('/login');
  next();
})
```



如果访问的不在白名单里，他会先通过JwtAuthenticationTokenFilter，如果没有token或者token不正确，之后会通过RestAuthenticationEntryPoint类向前端返回200，但是response中自定义错误码为401

```json
{
    "code":401,
    "data":"Full authentication is required to access this resource",
    "message":"暂未登录或token已经过期"
}
```



## 登录逻辑

+ 第一次登录时，携带用户名密码（前端密码使用md5进行加密），因为用户登录接口是开放在白名单里的，SpringSecurity直接放行，不会拦截

+ 会直接进入到UserController中，首先在Redis中通过用户名查询是否有用户信息，如果没有则到数据库中根据用户名查询，如果数据库中查不到用户信息，或查到的用户是禁用状态，则抛出异常，通过全局异常处理，返回前端相应的提示信息。如果数据库中查到了，则先存入Redis缓存中，并进行下一步处理

+ 如果成功查到用户信息，则校验用户密码是否正确（通过passwordEncoder将前端密码加密，与数据库中的密码对比。用户登录时，密码匹配阶段并没有进行密码解密（因为密码经过Hash处理，是不可逆的），而是使用相同的算法把用户输入的密码进行hash处理，得到密码的hash值，然后将其与从数据库中查询到的密码hash值进行比较。如果两者相同，说明用户输入的密码正确。），不正确则返回

+ 正确则通过SecurityContextHolder保存该用户信息的安全上下文，基于ThreadLocal的工作方式

+ 同时通过用户名，当前时间、配置文件设置的过期时间（7天过期）、加密算法（HS512）、密钥生成token，返回给前端

+ 当然还会经过自己配置的Spring AOP日志切面记录日志在控制台与磁盘中

+ 

+ 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里；

+ ```
    window.sessionStorage.setItem("token", res.data.data["token"]);
    ```

+ 在之后的请求中，客户端每次向服务端请求资源的时候需要带着服务端签发的 Token（在http的header中添加一个叫Authorization的头，值为Bearer + JWT的token）

+ 在SpringSecurity中，我自定义权限拦截器JWT过滤器（过滤器实际上就是对web资源进行拦截，做一些处理后再交给下一个过滤器或servlet处理。通常都是用来拦截request进行处理的，也可以对返回的response进行拦截处理，继承OncePerRequestFilter，他能够确保在一次请求只通过一次filter，而不需要重复执行。）

+ 在过滤器中首先获取请求头Authorization的内容，并且解析该请求头是否以Bearer开始，若是则获取相关token值，从token值中再获取用户名

+ 校验token是否被篡改

+ 获取用户名后，继续根据用户名加载用户信息（和上述账号密码认证用同一套逻辑，即先从缓存中找，找不到就加载数据库）

+ 随后验证token是否过期

+ 随后同样在SecurityContextHolder保存该用户信息的安全上下文

+ 如果最后验证成功，则进行正常的业务逻辑，向客户端返回请求的数据。