# 进阶

+ 项目的登录逻辑，前端的密码加密逻辑，注册的逻辑、传输明文不安全的解决办法、对密码加密使用了哪个算法
+ 项目的登录逻辑、设置token的过期时间、如果token被拦截伪造登录了咋办、单点登录

# Session和Cookie

## 背景

+ HTTP是一种无状态协议，即服务器不保留与客户交易时的任何状态。
+ 上一次的请求对这次的请求没有任何影响，服务端也不会对客户端上一次的请求进行任何记录处理。
+ 用户登录后，切换到其他界面，进行操作，服务器端是无法判断是哪个用户登录的。 每次进行页面跳转的时候，得重新登录。
+ 既然HTTP协议是无状态的，不会记录用户信息，那么怎么样才能让HTTP协议记录用户信息呢？换句话说，服务器怎么判断发来HTTP请求的是哪个用户？
+ 于是，两种用于保持HTTP状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。
+ cookie和session都是用来跟踪浏览器用户身份的会话方式。

## 区别



+ cookie数据保存在客户端，session数据保存在服务端。
+ cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，如果主要考虑到安全应当使用session
+ session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE
+ 将登陆信息等重要信息存放为SESSION；其他信息如果需要保留，可以放在COOKIE中

## Cookie

+ cookie 机制采用的是在客户端保持状态的方案。
+ Cookie 是服务器生成的，但是发送给客户端，并且由客户端来保存。每次请求加上 Cookie就行了。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

## Session

+ 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 Session。客户端浏览器再次访问时，只需要从该 Session 中查找该客户的状态就可以了。
+ Session 保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为 Session 需要使用Cookie 作为识别标志。HTTP协议是无状态的，Session 不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为 JSESSIONID 的 Cookie，它的值为该 Session 的 id（即放在HTTP响应报文头部信息里的Set-Cookie）。Session依据该 Cookie 来识别是否为同一用户。

## Cookie的工作原理

+ 浏览器端第一次发送请求到服务器端
+ 服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端
+ 浏览器端再次访问服务器端时会携带服务器端创建的Cookie
+ 服务器端通过Cookie中携带的数据区分不同的用户
+ sessionid是服务器和客户端连接时候随机分配的，如果浏览器使用的是cookie，那么所有数据都保存在浏览器端，比如你登陆以后，服务器设置了cookie用户名，那么当你再次请求服务器的时候，浏览器会将用户名一块发送给服务器，这些变量有一定的特殊标记。服务器会解释为cookie变量，所以只要不关闭浏览器，那么cookie变量一直是有效的，所以能够保证长时间不掉线。
+ 如果你能够截获某个用户的cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用cookie被攻击的可能性比较大。如果cookie设置了有效值，那么cookie会保存到客户端的硬盘上，下次在访问网站的时候，浏览器先检查有没有cookie，如果有的话，读取cookie，然后发送给服务器。

## Session的工作原理

+ 浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为session对象的ID），然后将该Cookie发送至浏览器端
+ 浏览器端发送第N次请求到服务器端，浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象
+ 服务器端根据name为JSESSIONID的Cookie的value(sessionId)去查询Session对象，从而区分不同用户。
+ 简单的说，当你登陆一个网站的时候，如果web服务器端使用的是session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登陆或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造。

session的常见实现形式是会话cookie（session cookie），即未设置过期时间的cookie，这个cookie的默认生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。实现机制是当用户发起一个请求的时候，服务器会检查该请求中是否包含sessionid，如果未包含，则系统会创造一个名为JSESSIONID的输出 cookie返回给浏览器(只放入内存，并不存在硬盘中)，并将其以HashTable的形式写到服务器的内存里面；当已经包含sessionid是，服务端会检查找到与该session相匹配的信息，如果存在则直接使用该sessionid，若不存在则重新生成新的 session。这里需要注意的是session始终是有服务端创建的，并非浏览器自己生成的。但是浏览器的cookie被禁止后session就需要用get方法的URL重写的机制或使用POST方法提交隐藏表单的形式来实现。

# JWT

JWT是JSON WEB TOKEN的缩写，是一种可以安全传输的的JSON对象， 是一种浏览器与服务器之间的一种身份认证机制。可实现无状态、分布式的Web应用授权。

特点是

- 安全：签名token，无法伪造。
- 无状态：不依赖服务端，不用维持会话。服务器就不保存任何 session 数据，服务器变成无状态。存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性

采用原始的token机制，放在`HTTP`请求的`header`中，`header`格式：

```xml
Authorization: Bearer <token>
```



JWT是一个含签名并携带用户相关信息的加密串，页面请求校验登录接口时，请求头中携带JWT串到后端服务，后端通过签名加密串匹配校验，保证信息未被篡改。校验通过则认为是可靠的请求，将正常返回数据。

在身份验证中，当用户使用其凭据成功登录时，将返回JSON Web Token（即：JWT）。由于令牌是凭证，因此必须非常小心以防止出现安全问题。一般情况下，不应将令牌保留的时间超过要求。理论上超时时间越短越好。

每当用户想要访问受保护的路由或资源时，用户代理应该使用Bearer模式发送JWT

在某些情况下，这可以作为无状态授权机制。服务器的受保护路由将检查Authorization header中的有效JWT ，如果有效，则允许用户访问受保护资源。如果JWT包含必要的数据，则可以减少查询数据库或缓存信息。



此时 signature字段就是关键了，能被解密出明文的，只有header和payload
假如黑客/中间人串改了payload，那么服务器可以通过signature去验证是否被篡改过。
在服务端在执行一次 signature = 加密算法(header + “.” + payload, 密钥);, 然后对比 signature 是否一致，如果一致则说明没有被篡改。
所以为什么说服务器的密钥不能被泄漏。
如果泄漏，将存在以下风险:
客户端可以自行签发 token
黑客/中间人可以肆意篡改 token



基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。

## JWT token的格式

**header.payload.signature**

- header中用于存放签名的生成算法、token的类型{"alg": "HS512","typ": "JWT"}
- payload中用于存放用户名、token的生成时间和过期时间
- signature：签名是把header和payload（载荷）对应的json结构进行base64 url编码之后得到的两个串，用英文句点号拼接起来，然后根据header里面alg指定的签名算法生成出来的。JWT 的最后一部分是 Signature ，这部分内容有三个部分，先是用 Base64 编码的 header 和 payload ，再用加密算法加密一下，加密的时候要放进去一个 Secret ，这个相当于是一个密码，这个密码秘密地存储在服务端。

## JWT实现认证和授权的原理

1. 客户端使用用户名跟密码请求登录；
2. 服务端收到请求，去验证用户名与密码；
3. 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端；
4. 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里；
5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token（在http的header中添加一个叫Authorization的头，值为JWT的token）；
6. 服务端收到请求，通过对Authorization头中信息的解码及数字签名校验来获取其中的用户信息，从而实现认证和授权，进一步解析 Token 内容，获知用户身份。如果验证成功，就向客户端返回请求的数据。



服务端仅验证 Token 合法性，校验 Token 合法性需要确认几件事情：

- Token 有没有过期
- 是不是自己签发的

**区别** 

+ session 存储在服务端占用服务器资源，而 JWT 存储在客户端
+ session 存储在 Cookie 中，存在伪造跨站请求伪造攻击的风险
+ session 只存在一台服务器上，那么下次请求就必须请求这台服务器，不利于分布式应用 
+ 存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性

**优点**

1. 解决跨域问题：这种基于Token的访问策略可以克服cookies的跨域问题。
2. 服务端无状态可以横向扩展，Token可完成认证，无需存储Session。
3. 系统解耦，Token携带所有的用户信息，无需绑定一个特定的认证方案，只需要知道加密的方法和密钥就可以进行加密解密，有利于解耦。
4. 防止跨站点脚本攻击，没有cookie技术，无需考虑跨站请求的安全问题。

## 优点

Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输. 
无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息. 
更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可. 
去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可. 
更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。 
CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。 
性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多. 
不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理. 
基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.

# 登录功能

## 无权限控制

前端配置了挂载路由导航守卫，如果请求的不是登录页并且sessionStorage中没有token，则跳转登录页面

```javascript
//挂载路由导航守卫
router.beforeEach((to, from, next) => {
  if (to.path === '/login' || to.path === '/register') {
    window.sessionStorage.clear();
    return next();
  }
  if (to.path === '/home') {
    return next();
  }
  //获取token
  const tokenStr = window.sessionStorage.getItem('token');
  //无token强制跳转到登录页面
  if (!tokenStr) return next('/login');
  next();
})
```



如果访问的不在白名单里，他会先通过JwtAuthenticationTokenFilter，如果没有token或者token不正确，之后会通过RestAuthenticationEntryPoint类向前端返回200，但是response中自定义错误码为401

```json
{
    "code":401,
    "data":"Full authentication is required to access this resource",
    "message":"暂未登录或token已经过期"
}
```



## 登录逻辑

+ 第一次登录时，携带用户名密码（前端密码使用md5进行加密），因为用户登录接口是开放在白名单里的，SpringSecurity直接放行，不会拦截

+ 会直接进入到UserController中，首先在Redis中通过用户名查询是否有用户信息，如果没有则到数据库中根据用户名查询，如果数据库中查不到用户信息，或查到的用户是禁用状态，则抛出异常，通过全局异常处理，返回前端相应的提示信息。如果数据库中查到了，则先存入Redis缓存中，并进行下一步处理

+ 如果成功查到用户信息，则校验用户密码是否正确（通过passwordEncoder将前端密码加密，与数据库中的密码对比。用户登录时，密码匹配阶段并没有进行密码解密（因为密码经过Hash处理，是不可逆的），而是使用相同的算法把用户输入的密码进行hash处理，得到密码的hash值，然后将其与从数据库中查询到的密码hash值进行比较。如果两者相同，说明用户输入的密码正确。），不正确则返回

+ 正确则通过SecurityContextHolder保存该用户信息的安全上下文，基于ThreadLocal的工作方式

+ 同时通过用户名，当前时间、配置文件设置的过期时间（7天过期）、加密算法（HS512）、密钥生成token，返回给前端

+ 当然还会经过自己配置的Spring AOP日志切面记录日志在控制台与磁盘中

+ 

+ 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里；

+ ```
    window.sessionStorage.setItem("token", res.data.data["token"]);
    ```

+ 在之后的请求中，客户端每次向服务端请求资源的时候需要带着服务端签发的 Token（在http的header中添加一个叫Authorization的头，值为Bearer + JWT的token）

+ 在SpringSecurity中，我自定义权限拦截器JWT过滤器（过滤器实际上就是对web资源进行拦截，做一些处理后再交给下一个过滤器或servlet处理。通常都是用来拦截request进行处理的，也可以对返回的response进行拦截处理，继承OncePerRequestFilter，他能够确保在一次请求只通过一次filter，而不需要重复执行。）

+ 在过滤器中首先获取请求头Authorization的内容，并且解析该请求头是否以Bearer开始，若是则获取相关token值，从token值中再获取用户名

+ 校验token是否被篡改

+ 获取用户名后，继续根据用户名加载用户信息（和上述账号密码认证用同一套逻辑，即先从缓存中找，找不到就加载数据库）

+ 随后验证token是否过期

+ 随后同样在SecurityContextHolder保存该用户信息的安全上下文

+ 如果最后验证成功，则进行正常的业务逻辑，向客户端返回请求的数据。

# 加密算法

HTTPS 解决数据传输安全问题的方案就是使用加密算法，具体来说是混合加密算法，也就是**对称加密和非对称加密的混合使用**，这里有必要先了解一下这两种加密算法的区别和优缺点。

## 对称加密

加密和解密都是使用同一个密钥

- 优点：算法公开、计算量小、加密速度快、加密效率高，适合加密比较大的数据。
- 缺点：
    1. 交易双方需要使用相同的密钥，也就**无法避免密钥的传输**，而密钥在传输过程中无法保证不被截获，因此对称加密的安全性得不到保证。
    2. 每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得发收信双方所拥有的钥匙数量急剧增长，**密钥管理**成为双方的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。

数据发信方将**明文和加密密钥**一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的**密钥及相同算法的逆算法对密文进行解密**，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。

## 非对称加密

加密和解密需要使用两个不同的密钥：公钥（public key）和私钥（private key）。公钥与私钥是一对，**如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用私钥对数据进行加密，那么只有用对应的公钥才能解密。**

非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公钥对外公开；得到该公钥的乙方使用公钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的私钥对加密后的信息进行解密。



常用的非对称加密算法是 RSA 算法

- 优点：算法公开，加密和解密使用不同的钥匙，私钥不需要通过网络进行传输，安全性很高。
- 缺点：**计算量比较大**，加密和解密速度相比对称加密慢很多。

## HASH算法

有MD5，SHA1，SHA256。用来确认信息没有被篡改。主要用来生成签名，签名是加在信息后面的，可以证明信息没有被修改过。一般对信息先做hash计算得到一个hash值，然后用私钥加密（这个加密一般是非对称加密）作为一个签名和信息一起发送。接收方收到信息后重新计算信息的hash值，且和信息所附带的hash值解密后进行对比。如果一样则认为没有被修改，反之则认为修改过，不做处理。可能有一种情况，黑客修改了信息并把hash值也改了，从而让他们相匹配。所以hash值一般都是加密后（生成签名）再和信息一起发送，确保hash值不会被修改。

常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性;
　　在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密;

### MD5

散列函数主要用于验证数据的完整性。

MD5算法是典型的消息摘要算法。其原理都是接受一个任意长度的消息并产生一个128位的消息摘要。如果把得到的消息摘要转换成十六进制字符串，则会得到一个32字节长度的字符串，我们平常见到的大部分MD数字指纹就是一个长度为32的十六进制字符串。

散列函数具有以下特性：

1. 散列函数的运算过程是不可逆的，这个称为散列函数的单向性。
2. 对于一个已知的消息及其散列值，要找到另外一个消息使其获得相同的散列值是不可能的，这个特性称为散列函数的弱碰撞性。这个特性可以用来防止消息伪造。
3. 任意两个不同消息的散列值一定不同。
4. 对原始消息长度没有限制。

任何消息经过散列函数处理后，都会产生一个唯一的散列值，这个散列值可以用来验证消息的完整性。计算消息散列值的过程被称为“消息摘要”，计算消息散列值的算法被称为消息摘要算法。

**MD5功能**

输入任意长度的信息，经过处理，输出为128位的信息（数字指纹）；
不同的输入得到的不同的结果（唯一性）；

**MD5不属于加密算法**

不能从密文（散列值）反过来得到原文，即没有解密算法，所以这部分人认为MD5只能属于算法，不能称为加密算法；

**MD5算法不可逆**

MD5不可逆的原因是其是一种散列函数，使用的是hash算法，在计算过程中原文的部分信息是丢失了的。

MD5相当于超损压缩。

**MD5用途**

1.防止被篡改：
1）比如发送一个电子文档，发送前，我先得到MD5的输出结果a。然后在对方收到电子文档后，对方也得到一个MD5的输出结果b。如果a与b一样就代表中途未被篡改。
2）比如我提供文件下载，为了防止不法分子在安装程序中添加木马，我可以在网站上公布由安装文件得到的MD5输出结果。
3）SVN在检测文件是否在CheckOut后被修改过，也是用到了MD5.

2.防止直接看到明文：
现在很多网站在数据库存储用户的密码的时候都是存储用户密码的MD5值。这样就算不法分子得到数据库的用户密码的MD5值，也无法知道用户的密码。（比如在UNIX系统中用户的密码就是以MD5（或其它类似的算法）经加密后存储在文件系统中。当用户登录的时候，系统把用户输入的密码计算成MD5值，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度。）

3.防止抵赖（数字签名）：
这需要一个第三方认证机构。例如A写了一个文件，认证机构对此文件用MD5算法产生摘要信息并做好记录。若以后A说这文件不是他写的，权威机构只需对此文件重新产生摘要信息，然后跟记录在册的摘要信息进行比对，相同的话，就证明是A写的了。这就是所谓的“数字签名”。

**MD5安全性**

普遍认为MD5是很安全，因为暴力破解的时间是一般人无法接受的。实际上如果把用户的密码MD5处理后再存储到数据库，其实是很不安全的。因为用户的密码是比较短的，而且很多用户的密码都使用生日，手机号码，身份证号码，电话号码等等。或者使用常用的一些吉利的数字，或者某个英文单词。如果我把常用的密码先MD5处理，把数据存储起来，然后再跟你的MD5结果匹配，这时我就有可能得到明文。所以现在大多数网站密码的策略是强制要求用户使用数字大小写字母的组合的方式提高用户密码的安全度。

**加盐**

我们要保存用户名密码的时候，显然明文保存是不太可取的，万一你的数据库的账号密码都被泄露了，那那些在你数据库中的密码不是都没泄露出去了吗？

所以我们要对密码进行加密。



我们知道，如果直接对密码进行散列，那么黑客可以对通过获得这个密码散列值，然后通过查散列值字典（例如MD5密码破解网站），得到某用户的密码。

加Salt可以一定程度上解决这一问题。所谓加Salt方法，就是加点“佐料”。其基本想法是这样的：当用户首次提供密码时（通常是注册时），由系统自动往这个密码里撒一些“佐料”，然后再散列。而当用户登录时，系统为用户提供的代码撒上同样的“佐料”，然后散列，再比较散列值，已确定密码是否正确。

一般加密算法固定，很容易破解，安全系数低，有很多网站可以直接破解密文。为了提高安全性，可以采取加盐的方式。生成一组随机串，保存在数据库中，然后混杂在原来的密码中，再通过加密算法加密，存进数据库中

合适的加盐以后可以解决大多数彩虹表带来的危险。

每次哈希计算时生成一个随机数，加入计算，并将随机数一并发送，所以相同的明文每次加盐后得到的摘要都不同，有效防止反向查询

**破解**

这里所谓的破解，并非把摘要还原成原文。为什么呢？因为固定128位的摘要是有穷的，而原文数量是无穷的，每一个摘要都可以由若干个原文通过Hash得到。

对于MD5的破解，实际上都属于【碰撞】。比如原文A通过MD5可以生成摘要M，我们并不需要把X还原成A，只需要找到原文B，生成同样的摘要M即可。

设MD5的哈希函数是H（X），那么：

H(A) = M

H(B) = M

任意一个B即为破解结果。

B有可能等于A，也可能不等于A。

MD5碰撞通常用于登陆密码的破解。应用系统的数据库中存储的用户密码通常都是原密码的MD5哈希值，每当用户登录时，验签过程如下：

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/20180402205353564)

如果我们得到了用户ABC的密码哈希值E10ADC3949BA59ABBE56E057F20F883E，并不需要还原出原密码123456，只需要“碰撞”出另一个原文654321（只是举例）即可。登录时，完全可以使用654321作为登陆密码，欺骗过应用系统的验签。

**暴力枚举法**

简单粗暴地枚举出所有原文，并计算出它们的哈希值，看看哪个哈希值和给定的信息摘要一致。这种方法虽然简单，但是时间复杂度极高。

**字典法**

字典法则是用空间换时间。黑客利用一个巨大的字典，存储尽可能多的原文和对应的哈希值。每次用给定的信息摘要查找字典，即可快速找到碰撞的结果。

**彩虹表法**

# HTTPS

## 性质

HTTPS = HTTP + SSL / TLS

HTTP+加密+认证+完整性保护 = HTTPS

超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。



HTTPS安全是由一套安全机制来保证的，主要包含这4个特性：**机密性、完整性、真实性和不可否认性**。 

- 机密性是指传输的数据是采用Session Key（会话密钥）加密的，在网络上是看不到明文的。
- 完整性是指为了避免网络中传输的数据被非法篡改，使用MAC算法来保证消息的完整性。
- 真实性是指通信的对方是可信的，利用了PKI（Public Key Infrastructure 即『公钥基础设施』）来保证公钥的真实性。
- 不可否认性是这个消息就是你给我发的，无法伪装和否认，是因为使用了签名的技术来保证的。

## 理解

HTTPS协议的主要功能基本都依赖于TLS/SSL协议，TLS/SSL的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/1634e5e77c014d22)

**HTTPS 和 HTTP 的区别：**

- 最最重要的区别就是安全性，HTTP 明文传输，不对数据进行加密安全性较差。HTTPS (HTTP + SSL / TLS)的数据传输过程是加密的，安全性较好。
- 使用 HTTPS 协议需要申请 CA 证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、DigiCert 和 GlobalSign 等。
- HTTP 页面响应速度比 HTTPS 快，这个很好理解，由于加了一层安全层，建立连接的过程更复杂，也要交换更多的数据，难免影响速度。
- 由于 HTTPS 是建构在 SSL / TLS 之上的 HTTP 协议，所以，要比 HTTP 更耗费服务器资源。
- HTTPS 和 HTTP 使用的是完全不同的连接方式，用的端口也不一样，前者是 443，后者是 80。

**HTTPS 的缺点：**

- 在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。
- HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。
- 在现有的证书机制下，中间人攻击依然有可能发生。
- HTTPS 需要更多的服务器资源，也会导致成本的升高。

## 流程

HTTPS 的整个通信过程可以分为两大阶段：证书验证和数据传输阶段，数据传输阶段又可以分为非对称加密和对称加密两个阶段。

![HTTPS 加密、解密、验证及数据传输过程.png](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/bVbClUl)

1.客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口)。

2.采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书，证书是需要申请的，并由专门的数字证书认证机构(CA)通过非常严格的审核之后颁发的电子证书。颁发证书的同时会产生一个**服务器的**私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。

3.服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。Chrome 浏览器点击地址栏的锁标志再点击证书就可以看到证书详细信息。

4.客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。

5.客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。

6.服务器在收到随机码 KEY 之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。

7.服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。

8.双方使用对称加密愉快地传输所有数据。

## 证书

**RSA身份验证的隐患**

身份验证和密钥协商是TLS的基础功能，要求的前提是合法的服务器掌握着对应的私钥。但RSA算法无法确保服务器身份的合法性，因为公钥并不包含服务器的信息，存在安全隐患:

- 客户端C和服务器S进行通信，中间节点M截获了二者的通信;
- 节点M自己计算产生一对公钥pub_M和私钥pri_M;
- C向S请求公钥时，M把自己的公钥pub_M发给了C;
- C使用公钥 pub_M加密的数据能够被M解密，因为M掌握对应的私钥pri_M，而 C无法根据公钥信息判断服务器的身份，从而 C和 * M之间建立了"可信"加密连接;
- 中间节点 M和服务器S之间再建立合法的连接，因此 C和 S之间通信被M完全掌握，M可以进行信息的窃听、篡改等操作。
- 另外，服务器也可以对自己的发出的信息进行否认，不承认相关信息是自己发出。

因此该方案下至少存在两类问题：中间人攻击和信息抵赖。



![img](https://user-gold-cdn.xitu.io/2018/5/11/1634e5e77bf0d89c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

**身份验证CA和证书**

解决上述身份验证问题的关键是确保获取的公钥途径是合法的，能够验证服务器的身份信息，为此需要引入权威的第三方机构CA(如沃通CA)。CA 负责核实公钥的拥有者的信息，并颁发认证"证书"，同时能够为使用者提供证书验证服务，即PKI体系(PKI基础知识)。

基本的原理为，CA负责审核信息，然后对关键信息利用私钥进行"签名"，公开对应的公钥，客户端可以利用公钥验证签名。CA也可以吊销已经签发的证书，基本的方式包括两类 CRL 文件和 OCSP。CA使用具体的流程如下：



![img](https://user-gold-cdn.xitu.io/2018/5/11/1634e5e77b83b06c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



 a.**服务方S**向第三方机构CA**提交**公钥、组织信息、个人信息(域名)等信息并申请认证;**（不交私钥）**
  b.**CA**通过线上、线下等多种手段**验证**申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;
  c.如信息审核通过，**CA**会向申请者签发认证文件-证书。
    证书包含以下信息：**申请者公钥**、申请者的组织信息和个人信息、签发机构**CA的信息**、有效时间、证书序列号等信息的明文，同时包含**一个签名**;
    **签名的产生算法**：首先，**使用散列函数计算公开的明文信息**的**信息摘要**，然后，采用**CA的私钥**对信息摘要进行**加密**，**密文即签名**;
  d.**客户端 C** 向服务器 S 发出请求时，**S 返回证书**文件;
  e.**客户端 C**读取证书中的相关的明文信息，**采用相同的散列函数**计算得到**信息摘要**，然后，利用**对应CA的公钥**解密签名数据，**对比证书的信息摘要**，如果一致，则可以确认证书的合法性，即公钥合法;
  f.**客户端**然后验证证书相关的域名信息、有效时间等信息;
  g.**客户端**会**内置信任**CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。

在这个过程注意几点：

a.申请证书不需要提供私钥，确保私钥永远只能服务器掌握;

b.证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名;

c.内置 CA 对应的证书称为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书（为什么说"部署自签SSL证书非常不安全"）

d.证书=公钥+申请者与颁发者信息+签名;

**即便有人截取服务器A证书，再发给客户端，想冒充服务器A，也无法实现。因为证书和url的域名是绑定的。**

**CA的作用：**

1）颁发证书，颁发证书其实就是使用CA的私钥对证书请求签名文件进行签名；

2）颁发的证书浏览器要信任，浏览器只需要用CA的公钥进行验签成功就表示这个证书是合法可信的，这就需要浏览器内置CA的公钥，也就是内置CA的证书。一般来说，操作系统都会内置权威CA的证书，有的浏览器会使用操作系统内置的CA证书列表，有的浏览器则自己维护的CA证书列表，比如Firefox。

**证书链**

如 CA根证书和服务器证书中间增加一级证书机构，即中间证书，证书的产生和验证原理不变，只是增加一层验证，只要最后能够被任何信任的CA根证书验证合法即可。

a.服务器证书 server.pem 的签发者为中间证书机构 inter，inter 根据证书 inter.pem 验证 server.pem 确实为自己签发的有效证书;

b.中间证书 inter.pem 的签发 CA 为 root，root 根据证书 root.pem 验证 inter.pem 为自己签发的合法证书;

c.客户端内置信任 CA 的 root.pem 证书，因此服务器证书 server.pem 的被信任。



![img](https://user-gold-cdn.xitu.io/2018/5/11/1634e5e780e86798?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



服务器证书、中间证书与根证书在一起组合成一条合法的证书链，证书链的验证是自下而上的信任传递的过程。 二级证书结构存在的优势：

a.减少根证书结构的管理工作量，可以更高效的进行证书的审核与签发;

b.根证书一般内置在客户端中，私钥一般离线存储，一旦私钥泄露，则吊销过程非常困难，无法及时补救;

c.中间证书结构的私钥泄露，则可以快速在线吊销，并重新为用户签发新的证书;

d.证书链四级以内一般不会对 HTTPS 的性能造成明显影响。

# SSO

单点登录英文全称Single Sign On，简称就是SSO。它的解释是：**在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。**

## CAS

CAS （Central Authentication Service）中心授权服务，本身是一个开源协议

CAS 包括两部分： CAS Server 和 CAS Client 。CAS Server 负责完成对用户的认证工作 , 需要独立部署 , CAS Server 会处理用户名 / 密码等凭证(Credentials) 。CAS Client与受保护的客户端应用部署在一起，以 Filter 方式保护受保护的资源。负责处理对客户端受保护资源的访问请求，需要对请求方进行身份认证时，重定向到 CAS Server 进行认证。（原则上，客户端应用不再接受任何的用户名密码等 Credentials）。

**流程**

CAS官网上的标准流程，具体流程如下：

1. 用户访问app系统，app系统是需要登录的，但用户现在没有登录。
2. 跳转到CAS server，即SSO登录系统，**以后图中的CAS Server我们统一叫做SSO系统。** SSO系统也没有登录，弹出用户登录页。
3. 用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。
4. SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。
5. app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。
6. 验证通过后，app系统将登录状态写入session并设置app域下的Cookie。

至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。

1. 用户访问app2系统，app2系统没有登录，跳转到SSO。
2. 由于SSO已经登录了，不需要重新登录认证。
3. SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。
4. app2拿到ST，后台访问SSO，验证ST是否有效。
5. 验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。