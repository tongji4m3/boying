# 涉及的查询

## 注册

查看用户是否存在

```sql
select count(*)
    from boying_user
    where username = #{username} or phone = #{telephone}
```

## 根据用户名查询

```sql
select
<include refid="Base_Column_List" />
from boying_user
where username = #{username}
```

## 根据手机号查询

```sql
select
<include refid="Base_Column_List" />
from boying_user
where phone = #{telephone}
```

## 菜单查询

```sql
select
    <include refid="Base_Column_List"/>
    from boying_category
    where admin_delete = 0
    order by weight desc
```

## 演出查询

```sql
select
    <include refid="Base_Column_List"/>
    from boying_show
    <where>
        <if test="categoryId != null and categoryId != 0">
            category_id = #{categoryId}
        </if>
        <if test="keyword != null and keyword != ''">
            and name like concat('%',#{keyword,jdbcType=VARCHAR},'%')
        </if>
        <if test="city != null and city != '' and city != '全国'">
            and city = #{city}
        </if>
        <if test="startDay != null and endDay != null">
            and start_time
            between #{startDay} and #{endDay}
        </if>
    </where>
    <if test="sort == null">
        order by weight desc
    </if>
    <if test="sort == 0">
        order by weight desc
    </if>
    <if test="sort == 1">
        order by START_TIME asc
    </if>
    <if test="sort == 2">
        order by START_TIME desc
    </if>
    <if test="sort == 3">
        order by MIN_PRICE asc
    </if>
    <if test="sort == 4">
        order by MIN_PRICE desc
    </if>
    <if test="sort == 5">
        order by MAX_PRICE asc
    </if>
    <if test="sort == 6">
        order by MAX_PRICE desc
    </if>
</select>
```

## 演出座次查询

```sql
select
<include refid="Base_Column_List"/>
from boying_seat
where show_id = #{showId}
```

## 查看该用户对该演出是否下单过

```sql
select count(*)
from boying_order
where user_id = #{userId}
  and show_id = #{showId}
  and status != 3
```

## 订单条件查询

```sql
select
<include refid="Base_Column_List"/>
from boying_order
where user_id = #{userId} and user_delete != 1
<if test="status != null and status != 0">
    and status = #{status}
</if>
<if test="name != null and name != ''">
    and show_id in
    (select id from boying_show where name like concat('%',#{name},'%')
</if>
```

## 查看并减库存

```sql
update boying_stock
set stock = stock - #{ticketCount}
where id = #{seatId}
  and stock >= #{ticketCount}
```

## 增加库存

```sql
update boying_stock
set stock = stock + #{ticketCount}
where id = #{seatId}
```

## 根据演出座次获取活动信息

```sql
select
<include refid="Base_Column_List"/>
from boying_promo
where seat_id = #{seatId,jdbcType=INTEGER}
```

# application.yml

## 多环境动态切换yml配置

在实际的的开发中，对于一个工程，经常会有多种环境配置，例如开发环境、测试环境、生产环境等。在不同的环境下，配置有可能是不一样的，比如接口地址、数据库连接配置等。为了避免频繁的修改配置文件，我们想要简便地切换各种环境配置。好在SpringBoot提供了这样的功能，可以很方便地切换不同场景下的配置。
	
对开发配置和生产环境做了配置。上面的配置是公共配置，下面我们分别配置了开发和生产的配置。`spring.profiles`表示配置的名称，`spring.profiles.active`表示要激活的环境，值和要切换的`spring.profiles`名称一致。默认激活的就是dev开发配置。
	
如果`spring.profiles.active`没有指定值，那么只会加载通用的配置。
	
工程打成jar包后，我们可以在运行的时候对配置进行选择，而不需要每次打包前都手动去修改`spring.profiles.active`的值。
	
例如在生产环境，我们可以使用release配置执行jar包`java -jar xxx.jar --spring.profiles.active=release`

如若配置:

```xml
spring:
  profiles:
    active: dev #默认为开发环境
```

会启动:`application.yml`与`application-dev.yml`

# config

## BoyingSecurityConfig

boying-security模块相关配置,在里面为UserDetailsService定义一个适用与boying-user组件的获取登录用户信息的方法。

```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class BoyingSecurityConfig extends SecurityConfig {

    @Autowired
    private BoyingUserService boyingUserService;

    /**
     * 注解@Bean放在方法上，产生一个Bean并且交给Spring容器管理
     * 定义用户信息
     */
    @Bean
    public UserDetailsService userDetailsService() {
        //为UserDetailsService定义一个适用与boying-user组件的获取登录用户信息的方法
        return username -> boyingUserService.loadUserByUsername(username);
    }
    //不添加基于路径的动态权限控制
}
```

## BoyingUserDetails

```java
/**
 * SpringSecurity需要的用户详情
 */
public class BoyingUserDetails implements UserDetails {
    private final BoyingUser user;

    public BoyingUserDetails(BoyingUser user) {
        this.user = user;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        //返回当前用户的角色
        return Arrays.asList(new SimpleGrantedAuthority("TEST"));
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUsername();
    }
    @Override
    public boolean isEnabled() {
        return user.getAdminDelete();
    }
}
```

## GlobalCorsConfig

全局跨域相关配置

## JacksonConfig

Jackson相关配置类,使得json不返回null的字段

## MyBatisConfig

MyBatis相关配置，控制dao或者mapper文件扫描位置

## SwaggerConfig

对boying-common的swagger相关组件进行自定义配置。Swagger API文档相关配置，主要是api扫描位置以及标题等

# param

用于将前端请求的参数封装成对象传递给service层，避免需要修改参数时controller、service方法传递的参数都要改变，编程过于繁琐

```java
@Getter
@Setter
@ToString
public class UserOrderParam {
    @ApiModelProperty(value = "showId")
    @NotNull(message = "演出Id不能为空")
    private Integer showId;

    @ApiModelProperty(value = "seatId")
    @NotNull(message = "演出座次Id不能为空")
    private Integer seatId;

    @ApiModelProperty(value = "promoId")
    private Integer promoId;

    @ApiModelProperty(value = "购买的票数（最多三张)")
    @NotNull(message = "购买的演出票数不能为空")
    @Max(3)
    @Min(1)
    private Integer count;

    @ApiModelProperty(value = "订单支付方式")
    @NotEmpty(message = "订单支付方式不能为空!")
    private String payment;
}
```



# VO、DTO

因为数据库表实体经常拆分

dataObject与数据库中一一映射

在service层有一个领域模型model的概念

返回给前端视图对象VO（View Object），因为一些用户敏感信息不应该被返回



所以在mapper中查询到dataObject后，需要组装成领域模型

在controller层调用service层返回给前端信息时，需要将领域模型转为VO

# Redis

## 验证码

生成验证码时，将自定义的Redis键值加上手机号生成一个Redis的key，以验证码为value存入到Redis中，并设置过期时间为自己配置的时间（这里为120s），并调用阿里云短信服务向手机号发送短信。校验验证码时根据手机号码来获取Redis里面存储的验证码，并与传入的验证码进行比对。

```java
# 自定义redis key
redis:
  database: boying
  key:
    authCode: 'user:authCode'
    user: 'user'
  expire:
    authCode: 90 # 验证码超期时间
    common: 86400 # 24小时


@Value("${redis.database}")
private String REDIS_DATABASE;
//    除验证码之外的过期时间
@Value("${redis.expire.common}")
private Long REDIS_EXPIRE;
@Value("${redis.expire.authCode}")
private Long REDIS_EXPIRE_AUTH_CODE;
//    用户以及验证码
@Value("${redis.key.user}")
private String REDIS_KEY_USER;
@Value("${redis.key.authCode}")
private String REDIS_KEY_AUTH_CODE;

@Override
public void setAuthCode(String telephone, String authCode) {
    String key = REDIS_DATABASE + ":" + REDIS_KEY_AUTH_CODE + ":" + telephone;
    //redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
    redisService.set(key, authCode, REDIS_EXPIRE_AUTH_CODE);
}

@Override
public String getAuthCode(String telephone) {
    String key = REDIS_DATABASE + ":" + REDIS_KEY_AUTH_CODE + ":" + telephone;
    return (String) redisService.get(key);
}
```

每次使用完毕（注册、更新密码等）都要删除密码

```java
//注册完删除验证码,每个验证码只能使用一次
boyingUserCacheService.delAuthCode(telephone);
```



## 用户信息

登录时，若缓存没有信息，则存入Redis中（用户名，用户信息）（手机号，用户信息）

```java
//boyingUserCacheService.setUser(user);//将查询到的数据放入缓存中

@Override
    public void setUser(BoyingUser user) {
        String key = REDIS_DATABASE + ":" + REDIS_KEY_USER + ":" + user.getUsername();
        String key2 = REDIS_DATABASE + ":" + REDIS_KEY_USER + ":" + user.getPhone();
//        设置两条,能通过手机号,用户名查到该用户
        redisService.set(key, user, REDIS_EXPIRE);
        redisService.set(key2, user, REDIS_EXPIRE);
    }
```

更新个人信息时，删除缓存

```java
    @Override
    public void delUser(int userId) {
//        确保全局不会redis缓存key混乱
        BoyingUser user = boyingUserMapper.selectByPrimaryKey(userId);
        if (user != null) {
            String key = REDIS_DATABASE + ":" + REDIS_KEY_USER + ":" + user.getUsername();
            String key2 = REDIS_DATABASE + ":" + REDIS_KEY_USER + ":" + user.getPhone();
            redisService.del(key);
            redisService.del(key2);
        }
    }
```

# 登录功能

如果没有携带token，则使用login方法

用户信息是通过缓存或数据库中查询，并封装成UserDetails对象

登录成功后将用户上下文信息存入SecurityContext中，并且生成Token返回。

```java
    @Override
    public String login(UsernameLoginParam param) {
        String username = param.getUsername();
        String password = param.getPassword();

        System.out.println(passwordEncoder.encode(password));

        String token = null;
        //密码需要客户端加密后传递,但是传递的仍然是明文
        UserDetails userDetails = loadUserByUsername(username);
        if (!passwordEncoder.matches(password, userDetails.getPassword())) {
            throw new BadCredentialsException("密码不正确");
        }
//            获取该用户的上下文信息
//            username和password被获得后封装到一个UsernamePasswordAuthenticationToken
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
//            围绕该用户建立安全上下文（security context）
        SecurityContextHolder.getContext().setAuthentication(authentication);
        token = jwtTokenUtil.generateToken(userDetails);
        return token;
    }

    @Override
    public UserDetails loadUserByUsername(String username) {
        BoyingUser user = getByUsername(username);
        return new BoyingUserDetails(user);
    }

    @Override
    public BoyingUser getByUsername(String username) {
        BoyingUser user = boyingUserCacheService.getUser(username);
        if (user != null) return user; //缓存里面有数据

        //根据用户名查询是否存在
        user = boyingUserMapper.selectByUsername(username);

        //不能给过于详细的错误提示！
        if (user == null) Asserts.fail("用户名或密码错误");

        //账号未启用
        if (user.getAdminDelete()) Asserts.fail("账号未启用,请联系管理员!");

        boyingUserCacheService.setUser(user);//将查询到的数据放入缓存中
        return user;
    }
```
## getCurrentUser()

```java
    @Override
    public BoyingUser getCurrentUser() {
//        获取之前登录存储的用户上下文信息
        //ThreadLocal
        SecurityContext ctx = SecurityContextHolder.getContext();
        Authentication auth = ctx.getAuthentication();
        BoyingUserDetails userDetails = (BoyingUserDetails) auth.getPrincipal();
        System.out.println(userDetails.getUser());
        return userDetails.getUser();
    }
```



## BoyingUserDetails

```java
/**
 * SpringSecurity需要的用户详情
 */
public class BoyingUserDetails implements UserDetails {
    private final BoyingUser user;

    public BoyingUserDetails(BoyingUser user) {
        this.user = user;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        //返回当前用户的角色
        return Arrays.asList(new SimpleGrantedAuthority("TEST"));
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUsername();
    }

    @Override
    public boolean isEnabled() {
        return user.getAdminDelete();
    }
}
```
## BoyingSecurityConfig

```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class BoyingSecurityConfig extends SecurityConfig {

    @Autowired
    private BoyingUserService boyingUserService;

    /**
     * 注解@Bean放在方法上，产生一个Bean并且交给Spring容器管理
     * 定义用户信息
     *
     * @return
     */
    @Bean
    public UserDetailsService userDetailsService() {
        //为UserDetailsService定义一个适用与boying-user组件的获取登录用户信息的方法
        return username -> boyingUserService.loadUserByUsername(username);
    }
    //不添加基于路径的动态权限控制
}
```

当有token时，过滤器会直接使用token进行登录：

```java
@Override
protected void doFilterInternal(HttpServletRequest request,
                                HttpServletResponse response,
                                FilterChain chain) throws ServletException, IOException
{
    //请求头有字段Authorization，并且以‘Bearer ’开头
    String authHeader = request.getHeader(this.tokenHeader);
    if (authHeader != null && authHeader.startsWith(this.tokenHead))
    {
        String authToken = authHeader.substring(this.tokenHead.length());// The part after "Bearer "
        String username = jwtTokenUtil.getUserNameFromToken(authToken);
        LOGGER.info("checking username:{}", username);
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null)
        {
            //SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限）
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);
            //验证用户名和是否已过期
            if (jwtTokenUtil.validateToken(authToken, userDetails))
            {
                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                LOGGER.info("authenticated user:{}", username);
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }
    }
    chain.doFilter(request, response);
}
```

# 活动

如果没有领域模型，处理起来很麻烦。





1. 用户进入订单页面，只能通过list获取到所有的订单列表，然后再进行查看详情、完成、取消、删除操作
2. 所以那些其他的操作不需要再判断订单是否存在，订单是否被用户删除
3. 但是需要判断是否被管理员删除，可能前端没设置





```java
 查询演出信息时，在List<BoyingSeatModel> getShowSeatList(Integer showId);等得到座次的方法中，BoyingSeatModel聚合了一个BoyingPromoModel，如果promoModel不为空，则表示其拥有还未结束的秒杀活动

BoyingPromoModel boyingPromoModel = boyingPromoService.getPromo(seatDO.getId());
 //存在秒杀活动，而且是未开始或者是正在进行中的
 if (boyingPromoModel != null && boyingPromoModel.getStatus() != 3) {
 boyingSeatModel.setBoyingPromoModel(boyingPromoModel);
 }
 
 
 BoyingPromoServiceImpl的getPromo(Integer seatId)将数据库中对应座次的秒杀活动取出来，如果不存在则返回null，并且转换为BoyingPromoModel（多了一个status字段表示秒杀活动状态 1表示还未开始，2表示进行中，3表示已结束）
 
 
  在返回给前端时，如果该演出座次有秒杀活动则返回给前端，没有则不返回
if (boyingSeatModel.getBoyingPromoModel() != null) {
	//有正在进行或即将进行的秒杀活动
	boyingSeatVO.setPromoStatus(boyingSeatModel.getBoyingPromoModel().getStatus());
    boyingSeatVO.setPromoId(boyingSeatModel.getBoyingPromoModel().getId());
    boyingSeatVO.setStartTime(boyingSeatModel.getBoyingPromoModel().getStartTime());
    boyingSeatVO.setPromoPrice(boyingSeatModel.getBoyingPromoModel().getPrice());
} 
else {
	boyingSeatVO.setPromoStatus(0);
}
```





