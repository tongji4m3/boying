# 目录结构

```
├───annotation
│       CacheException.java
│
├───aspect
│       RedisCacheAspect.java
│
├───component
│       DynamicAccessDecisionManager.java
│       DynamicSecurityFilter.java
│       DynamicSecurityMetadataSource.java
│       DynamicSecurityService.java
│       JwtAuthenticationTokenFilter.java
│       RestAuthenticationEntryPoint.java
│       RestfulAccessDeniedHandler.java
│
├───config
│       IgnoreUrlsConfig.java
│       RedisConfig.java
│       SecurityConfig.java
│
└───util
        JwtTokenUtil.java
```

# SpringSecurity

SpringSecurity 采用的是责任链的设计模式，它有一条很长的过滤器链。

Spring Security主要是从两个方面解决安全性问题：

1. **web请求级别**：使用Servlet规范中的过滤器（Filter）保护Web请求并限制URL级别的访问。
2. **方法调用级别**：使用Spring AOP保护方法调用，确保具有适当权限的用户才能访问安全保护的方法。

# JWT

JWT是JSON WEB TOKEN的缩写，是一种可以安全传输的的JSON对象，由于使用了数字签名，所以是可信任和安全的。

JWT是一个含签名并携带用户相关信息的加密串，页面请求校验登录接口时，请求头中携带JWT串到后端服务，后端通过签名加密串匹配校验，保证信息未被篡改。校验通过则认为是可靠的请求，将正常返回数据。

在身份验证中，当用户使用其凭据成功登录时，将返回JSON Web Token（即：JWT）。由于令牌是凭证，因此必须非常小心以防止出现安全问题。一般情况下，不应将令牌保留的时间超过要求。理论上超时时间越短越好。

每当用户想要访问受保护的路由或资源时，用户代理应该使用Bearer模式发送JWT

在某些情况下，这可以作为无状态授权机制。服务器的受保护路由将检查Authorization header中的有效JWT ，如果有效，则允许用户访问受保护资源。如果JWT包含必要的数据，则可以减少查询数据库或缓存信息。

## JWT token的格式

**header.payload.signature**

- header中用于存放签名的生成算法
- payload中用于存放用户名、token的生成时间和过期时间
- signature为以header和payload生成的签名，一旦header和payload被篡改，验证将失败

## JWT实现认证和授权的原理

1. 客户端使用用户名跟密码请求登录；
2. 服务端收到请求，去验证用户名与密码；
3. 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端；
4. 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里；
5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token（在http的header中添加一个叫Authorization的头，值为JWT的token）；
6. 服务端收到请求，通过对Authorization头中信息的解码及数字签名校验来获取其中的用户信息，从而实现认证和授权，进一步解析 Token 内容，获知用户身份。如果验证成功，就向客户端返回请求的数据。

JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。 { "姓名": "张三", "角色": "管理员", "到期时间": "2018年7月1日0点0分" } 以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。

**服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。**

服务端仅验证 Token 合法性

校验 Token 合法性需要确认几件事情：

- Token 有没有过期
- 是不是自己签发的

**QA**

- JWT 的 Payload 安全吗？ 不安全，仅经 Base64 编码过，相当于明文传输，因此不要携带敏感数据
- 用户输入的密码需要在客户端加密吗？ 不需要加密，直接明文传，客户端密码安全由 SSL 保证
- 服务端收到密码应该如何加密？ 一般做法是 Hash 加盐（Adding Salt to Hashing），具体见Adding Salt to Hashing: A Better Way to Store Passwords

**区别** 

+ session 存储在服务端占用服务器资源，而 JWT 存储在客户端
+ session 存储在 Cookie 中，存在伪造跨站请求伪造攻击的风险
+ session 只存在一台服务器上，那么下次请求就必须请求这台服务器，不利于分布式应用 
+ 存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性

**为什么使用 JWT**

1）可以通过URL POST参数或者http header中发送，数据量小，传输速度快。

2）自包含：负载中包含了用户所需要的所有信息，避免多次查询数据库。

**优点**

1. 解决跨域问题：这种基于Token的访问策略可以克服cookies的跨域问题。
2. 服务端无状态可以横向扩展，Token可完成认证，无需存储Session。
3. 系统解耦，Token携带所有的用户信息，无需绑定一个特定的认证方案，只需要知道加密的方法和密钥就可以进行加密解密，有利于解耦。
4. 防止跨站点脚本攻击，没有cookie技术，无需考虑跨站请求的安全问题。

# JwtTokenUtil

用于生成和解析JWT token的工具类

```yml
jwt:
  tokenHeader: Authorization #JWT存储的请求头
  secret: boying-user-secret #JWT加解密使用的密钥
  expiration: 604800 #JWT的超期限时间(60*60*24*7) 7天过期
  tokenHead: 'Bearer '  #JWT负载中拿到开头
```

```java
public class JwtTokenUtil
{
    private static final String CLAIM_KEY_USERNAME = "sub";
    private static final String CLAIM_KEY_CREATED = "created";
    @Value("${jwt.secret}")
    private String secret;
    @Value("${jwt.expiration}")
    private Long expiration;
    @Value("${jwt.tokenHead}")
    private String tokenHead;
    
    /**
     * 根据登录用户信息生成token
     */
    public String generateToken(UserDetails userDetails)
    {
        Map<String, Object> claims = new HashMap<>();
        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());
        claims.put(CLAIM_KEY_CREATED, new Date());
        return generateToken(claims);
    }
    /**
     * 根据负责生成JWT的token
     */
    private String generateToken(Map<String, Object> claims)
    {
        return Jwts.builder()
                .setClaims(claims)
                .setExpiration(generateExpirationDate())
                .signWith(SignatureAlgorithm.HS512, secret)
                .compact();
    }
    /**
     * 生成token的过期时间
     */
    private Date generateExpirationDate()
    {
        return new Date(System.currentTimeMillis() + expiration * 1000);
    }
    
    
    /**
     * 从token中获取登录用户名
     */
    public String getUserNameFromToken(String token)
    {
        String username;
        try
        {
            Claims claims = getClaimsFromToken(token);
            username = claims.getSubject();
        }
        catch (Exception e)
        {
            username = null;
        }
        return username;
    }
    
    
    
    
    /**
     * 验证token是否还有效
     *
     * @param token       客户端传入的token
     * @param userDetails 从数据库中查询出来的用户信息
     */
    public boolean validateToken(String token, UserDetails userDetails)
    {
        String username = getUserNameFromToken(token);
        return username.equals(userDetails.getUsername()) && !isTokenExpired(token);
    }

    /**
     * 判断token是否已经失效
     */
    private boolean isTokenExpired(String token)
    {
        Date expiredDate = getExpiredDateFromToken(token);
        return expiredDate.before(new Date());
    }
}

```



# SecurityConfig

对SpringSecurity的配置的扩展，支持自定义白名单资源路径和查询用户逻辑，其他的所有类都是为它服务的

```java
public class SecurityConfig extends WebSecurityConfigurerAdapter
{
     /**
     * 用于配置需要拦截的url路径、jwt过滤器及出异常后的处理器；
     * 安全拦截器
     */
     @Override
    protected void configure(HttpSecurity httpSecurity) throws Exception
    {
        //不需要保护的资源路径允许访问
        for (String url : ignoreUrlsConfig().getUrls())
        {
            registry.antMatchers(url).permitAll();
        }
        // 任何请求需要身份认证
        registry
                .accessDeniedHandler(restfulAccessDeniedHandler())// 无权限处理
                .authenticationEntryPoint(restAuthenticationEntryPoint())//未登录处理
                .addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);//权限拦截器JWT过滤器
    }
    @Bean
    public IgnoreUrlsConfig ignoreUrlsConfig()
    {
        return new IgnoreUrlsConfig();
    }
	/**
     * 当用户没有访问权限时,将调用该方法。是没有访问权限时的处理器，用于返回JSON格式的处理结果
     */
    @Bean
    public RestfulAccessDeniedHandler restfulAccessDeniedHandler()
    {
        return new RestfulAccessDeniedHandler();
    }
     /**
     * 当未登录或token失效时，返回JSON格式的结果
     *
     * @return
     */
    @Bean
    public RestAuthenticationEntryPoint restAuthenticationEntryPoint()
    {
        return new RestAuthenticationEntryPoint();
    }
    /**
     * 在用户名和密码校验前添加的过滤器，如果有jwt的token，会自行根据token信息进行登录。
     *
     * @return
     */
    @Bean
    public JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter()
    {
        return new JwtAuthenticationTokenFilter();
    }
    
    
    
    /**
     * 用于配置UserDetailsService及PasswordEncoder
     */
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception
    {
        //UserDetailsService:SpringSecurity定义的核心接口，用于根据用户名获取用户信息，需要自行实现
        auth.userDetailsService(userDetailsService())
                .passwordEncoder(passwordEncoder());
    }
    /**
     * SpringSecurity定义的用于对密码进行编码及比对的接口，目前使用的是BCryptPasswordEncoder
     */
    @Bean
    public PasswordEncoder passwordEncoder()
    {
        return new BCryptPasswordEncoder();
    }
}
```

## IgnoreUrlsConfig

处理SecurityConfig中的白名单，用于不需要保护的资源路径允许访问

```yml
secure:
  ignored:
    urls: #安全路径白名单
      - /swagger-ui.html
      - /user/**
      - /home/**
```

```java
/**
 * 用于配置白名单资源路径
 * 将大量的参数配置在 application.yml 文件中，
 * 通过 @ConfigurationProperties 注解，我们可以方便的获取这些参数值
 */
@Getter
@Setter
@ConfigurationProperties(prefix = "secure.ignored")
public class IgnoreUrlsConfig
{

    private List<String> urls = new ArrayList<>();

}
```

## RestfulAccessDeniedHandler

```java
/**
 * 处理SecurityConfig中没有权限访问时自定义返回结果，返回403相关信息
 * 自定义返回结果：没有权限访问时
 * 返回403相关信息
 */
public class RestfulAccessDeniedHandler implements AccessDeniedHandler
{
    @Override
    public void handle(HttpServletRequest request,
                       HttpServletResponse response,
                       AccessDeniedException e) throws IOException, ServletException
    {     response.getWriter().println(JSONUtil.parse(CommonResult.forbidden(e.getMessage())));
        response.getWriter().flush();
    }
}
```

## RestAuthenticationEntryPoint

```java
/**
 * 自定义返回结果：未登录或登录过期
 * 即返回401相关信息
 */
public class RestAuthenticationEntryPoint implements AuthenticationEntryPoint
{
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException
    {
        response.setHeader("Access-Control-Allow-Origin", "*");
        response.setHeader("Cache-Control", "no-cache");
        response.setCharacterEncoding("UTF-8");
        response.setContentType("application/json");
        response.getWriter().println(JSONUtil.parse(CommonResult.unauthorized(authException.getMessage())));
        response.getWriter().flush();
    }
}
```

## JwtAuthenticationTokenFilter

处理SecurityConfig，在用户名和密码校验前添加的过滤器，如果请求中有jwt的token且有效，会取出token中的用户名，然后调用SpringSecurity的API进行登录操作。

```java
/**
 * JWT登录授权过滤器
 
  tokenHeader: Authorization #JWT存储的请求头
  tokenHead: 'Bearer '  #JWT负载中拿到开头
 */
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter
{
 
    /**
     * SpringSecurity定义的核心接口，用于根据用户名获取用户信息
     */
    @Autowired
    private UserDetailsService userDetailsService;
    @Autowired
    private JwtTokenUtil jwtTokenUtil;
    @Value("${jwt.tokenHeader}")
    private String tokenHeader;
    @Value("${jwt.tokenHead}")
    private String tokenHead;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException
    {
        //请求头有字段Authorization，并且以‘Bearer ’开头
        String authHeader = request.getHeader(this.tokenHeader);
        if (authHeader != null && authHeader.startsWith(this.tokenHead))
        {
            String authToken = authHeader.substring(this.tokenHead.length());// The part after "Bearer "
            String username = jwtTokenUtil.getUserNameFromToken(authToken);
            LOGGER.info("checking username:{}", username);
            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null)
            {
                //SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限）
                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);
                ////验证用户名和是否已过期
                if (jwtTokenUtil.validateToken(authToken, userDetails))
                {
                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    LOGGER.info("authenticated user:{}", username);
                    SecurityContextHolder.getContext().setAuthentication(authentication);
                }
            }
        }
        chain.doFilter(request, response);
    }
}
```



## BoyingSecurityConfig

实现了对SecurityConfig的扩展，获取用户信息和用户拥有的权限

```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class BoyingSecurityConfig extends SecurityConfig
{

    @Autowired
    private UmsAdminService adminService;
    @Autowired
    private UmsResourceService resourceService;

    //实现security模块的该方法，根据用户名获取用户信息
    @Bean
    public UserDetailsService userDetailsService()
    {
        //获取登录用户信息
        return username -> adminService.loadUserByUsername(username);
        /*
        @Override
        public UserDetails loadUserByUsername(String username)
        {
            //获取用户信息
            AdminUser AdminUser = getAdminByUsername(username);
            if (AdminUser != null)
            {
                List<AdminResource> resourceList = getResourceList(AdminUser.getId());
                return new AdminUserDetails(AdminUser, resourceList);
            }
            throw new UsernameNotFoundException("用户名或密码错误");
        }
        */
    }

    //    加载所有的资源 资源路径url,资源路径值(自定义为了 id:name )
    @Bean
    public DynamicSecurityService dynamicSecurityService()
    {
        return new DynamicSecurityService()
        {
            @Override
            public Map<String, ConfigAttribute> loadDataSource()
            {
                Map<String, ConfigAttribute> map = new ConcurrentHashMap<>();
                List<AdminResource> resourceList = resourceService.listAll();
                for (AdminResource resource : resourceList)
                {
                    map.put(resource.getUrl(), new org.springframework.security.access.SecurityConfig(resource.getId() + ":" + resource.getName()));
                }
                return map;
            }
        };
    }
}
```

## UserDetails

SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限）

```java
public interface UserDetails extends Serializable 
{
    Collection<? extends GrantedAuthority> getAuthorities();

    String getPassword();

    String getUsername();

    boolean isEnabled();
}
```

## AdminUserDetails

```java
/**
 * SpringSecurity需要的用户详情
 */
public class AdminUserDetails implements UserDetails
{
    private final AdminUser adminUser;
    private final List<AdminResource> resourceList;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities()
    {
        //返回当前用户拥有的资源权限
        return resourceList.stream()
                .map(AdminResource -> new SimpleGrantedAuthority(AdminResource.getId() + ":" + AdminResource.getName()))
                .collect(Collectors.toList());
    }
    
     @Override
    public String getPassword()
    {
        return adminUser.getPassword();
    }

    @Override
    public String getUsername()
    {
        return adminUser.getUsername();
    }

    @Override
    public boolean isEnabled()
    {
        return adminUser.getStatus();
    }

}
```



# 基于路径的动态权限控制

修改Spring Security的配置类SecurityConfig，当有动态权限业务类时在FilterSecurityInterceptor过滤器前添加我们的动态权限过滤器。这里在创建动态权限相关对象时，还使用了@ConditionalOnBean这个注解，当没有动态权限业务类时就不会创建动态权限相关对象，实现了有动态权限控制和没有这两种情况的兼容。其他模块需要动态权限控制时，只要创建一个DynamicSecurityService对象就行

## DynamicSecurityFilter
动态权限过滤器，用于实现基于路径的动态权限过滤。对OPTIONS请求直接放行（防止跨域问题）。对白名单请求直接放行，所有的鉴权操作都会在`super.beforeInvocation(fi)`中进行

## DynamicSecurityMetadataSource
自己实现SecurityMetadataSource接口的getAttributes方法，用于获取当前访问路径所需资源。
		后台资源规则被缓存在了一个Map对象之中

`private static Map<String， ConfigAttribute> configAttributeMap = null;`，

所以当后台资源发生变化时，我们需要清空缓存的数据，当修改后台资源时，需要调用clearDataSource方法来清空缓存的数据。

通过`private DynamicSecurityService dynamicSecurityService;`获取后台资源规则

## DynamicAccessDecisionManager

实现AccessDecisionManager接口来实现权限校验，对于没有配置资源的接口我们直接允许访问，对于配置了资源的接口，我们把访问所需资源和用户拥有的资源进行比对，如果匹配则允许访问。

## DynamicSecurityService

动态权限相关业务类，自定义的一个动态权限业务接口，其主要用于加载所有的后台资源规则。

# AOP优化

给获取用户信息和获取用户的资源信息这两个操作添加缓存操作，当我们修改用户信息和资源信息时都需要删除缓存中的数据

## RedisCacheAspect

Redis缓存切面，防止Redis宕机影响正常业务逻辑

因为作为缓存，我们所希望的是，如果Redis宕机了，我们的业务逻辑不会有影响。要保证缓存业务类中的方法执行不影响正常的业务逻辑，就需要在所有方法中添加`try catch`逻辑。使用AOP，我们可以在一个地方写上`try catch`逻辑，然后应用到所有方法上去。

注意只对命名为`xxxCacheService`的起作用

## CacheException

自定义注解，有该注解的缓存方法会抛出异常。例如验证码存储，如果我们的Redis宕机了，我们的验证码存储接口需要的是报错，而不是返回执行成功。

# 前后端分离跨域问题

CORS全称Cross-Origin Resource Sharing，意为跨域资源共享。当一个资源去访问另一个不同域名或者同域名不同端口的资源时，就会发出跨域请求。如果此时另一个资源不允许其进行跨域资源访问，那么访问的那个资源就会遇到跨域问题。

## 添加GlobalCorsConfig配置文件来允许跨域访问。

```java
/**
 * 全局跨域配置
 */
@Configuration
public class GlobalCorsConfig {

    /**
     * 允许跨域调用的过滤器
     */
    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        //允许所有域名进行跨域调用
        config.addAllowedOrigin("*");
        //允许跨越发送cookie
        config.setAllowCredentials(true);
        //放行全部原始头信息
        config.addAllowedHeader("*");
        //允许所有请求方法跨域调用
        config.addAllowedMethod("*");
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return new CorsFilter(source);
    }
}
```

此时发现，需要登录认证的/admin/info接口的OPTIONS请求无法通过认证，那是因为复杂的跨越请求需要先进行一次OPTIONS请求进行预检，我们的应用整合了SpringSecurity，对OPTIONS请求并没有放开登录认证。

## 设置SpringSecurity允许OPTIONS请求访问

在SecurityConfig类的configure(HttpSecurity httpSecurity)方法中添加如下代码。

```java
.antMatchers(HttpMethod.OPTIONS)//跨域请求会先进行一次options请求
.permitAll()
```

## 一次完整的跨域请求

### 先发起一次OPTIONS请求进行预检

**请求头信息**

```text
Access-Control-Request-Headers: content-type
Access-Control-Request-Method: POST
Origin: http://localhost:8090
Referer: http://localhost:8090/
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36
```

**响应头信息**

```text
Access-Control-Allow-Credentials: true
Access-Control-Allow-Headers: content-type
Access-Control-Allow-Methods: POST
Access-Control-Allow-Origin: http://localhost:8090
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Content-Length: 0
Date: Sat, 27 Jul 2019 13:40:32 GMT
Expires: 0
Pragma: no-cache
Vary: Origin, Access-Control-Request-Method, Access-Control-Request-Headers
X-Content-Type-Options: nosniff
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
```

- 请求成功返回状态码为200

### 发起真实的跨域请求