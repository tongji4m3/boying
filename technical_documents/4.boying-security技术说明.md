---
title: boying-security技术说明
date: 2021-01-08
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 博影项目子模块——boying-security的结构，包括SecurityConfig、基于路径的动态权限控制等
categories: 博影项目笔记
tags:

  - 项目
  - SpringSecurity
  - AOP



---



# 目录结构

```
├───annotation
│       CacheException.java
│
├───aspect
│       RedisCacheAspect.java
│
├───component
│       DynamicAccessDecisionManager.java
│       DynamicSecurityFilter.java
│       DynamicSecurityMetadataSource.java
│       DynamicSecurityService.java
│       JwtAuthenticationTokenFilter.java
│       RestAuthenticationEntryPoint.java
│       RestfulAccessDeniedHandler.java
│
├───config
│       IgnoreUrlsConfig.java
│       RedisConfig.java
│       SecurityConfig.java
│
└───util
        JwtTokenUtil.java
```

# SpringSecurity

SpringSecurity是一个强大的可高度定制的认证和授权框架，对于Spring应用来说它是一套Web安全标准。SpringSecurity注重于为Java应用提供认证和授权功能，像所有的Spring项目一样，它对自定义需求具有强大的扩展性。

SpringSecurity 采用的是责任链的设计模式，它有一条很长的过滤器链。

Spring Security主要是从两个方面解决安全性问题：

1. **web请求级别**：使用Servlet规范中的过滤器（Filter）保护Web请求并限制URL级别的访问。
2. **方法调用级别**：使用Spring AOP保护方法调用，确保具有适当权限的用户才能访问安全保护的方法。

# JWT

JWT是JSON WEB TOKEN的缩写，是一种可以安全传输的的JSON对象， 是一种浏览器与服务器之间的一种身份认证机制。

特点是

- 安全：签名token，无法伪造。
- 无状态：不依赖服务端，不用维持会话。服务器就不保存任何 session 数据，服务器变成无状态。存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性

采用原始的token机制，放在`HTTP`请求的`header`中，`header`格式：

```xml
Authorization: Bearer <token>
```



JWT是一个含签名并携带用户相关信息的加密串，页面请求校验登录接口时，请求头中携带JWT串到后端服务，后端通过签名加密串匹配校验，保证信息未被篡改。校验通过则认为是可靠的请求，将正常返回数据。

在身份验证中，当用户使用其凭据成功登录时，将返回JSON Web Token（即：JWT）。由于令牌是凭证，因此必须非常小心以防止出现安全问题。一般情况下，不应将令牌保留的时间超过要求。理论上超时时间越短越好。

每当用户想要访问受保护的路由或资源时，用户代理应该使用Bearer模式发送JWT

在某些情况下，这可以作为无状态授权机制。服务器的受保护路由将检查Authorization header中的有效JWT ，如果有效，则允许用户访问受保护资源。如果JWT包含必要的数据，则可以减少查询数据库或缓存信息。

## JWT token的格式

**header.payload.signature**

- header中用于存放签名的生成算法、token的类型{"alg": "HS512","typ": "JWT"}
- payload中用于存放用户名、token的生成时间和过期时间
- signature：签名是把header和payload（载荷）对应的json结构进行base64 url编码之后得到的两个串，用英文句点号拼接起来，然后根据header里面alg指定的签名算法生成出来的。
- JWT 的最后一部分是 Signature ，这部分内容有三个部分，先是用 Base64 编码的 header 和 payload ，再用加密算法加密一下，加密的时候要放进去一个 Secret ，这个相当于是一个密码，这个密码秘密地存储在服务端。

## JWT实现认证和授权的原理

1. 客户端使用用户名跟密码请求登录；
2. 服务端收到请求，去验证用户名与密码；
3. 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端；
4. 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里；
5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token（在http的header中添加一个叫Authorization的头，值为JWT的token）；
6. 服务端收到请求，通过对Authorization头中信息的解码及数字签名校验来获取其中的用户信息，从而实现认证和授权，进一步解析 Token 内容，获知用户身份。如果验证成功，就向客户端返回请求的数据。



服务端仅验证 Token 合法性，校验 Token 合法性需要确认几件事情：

- Token 有没有过期
- 是不是自己签发的

**区别** 

+ session 存储在服务端占用服务器资源，而 JWT 存储在客户端
+ session 存储在 Cookie 中，存在伪造跨站请求伪造攻击的风险
+ session 只存在一台服务器上，那么下次请求就必须请求这台服务器，不利于分布式应用 
+ 存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性

**优点**

1. 解决跨域问题：这种基于Token的访问策略可以克服cookies的跨域问题。
2. 服务端无状态可以横向扩展，Token可完成认证，无需存储Session。
3. 系统解耦，Token携带所有的用户信息，无需绑定一个特定的认证方案，只需要知道加密的方法和密钥就可以进行加密解密，有利于解耦。
4. 防止跨站点脚本攻击，没有cookie技术，无需考虑跨站请求的安全问题。

# 登录功能

## 登录逻辑

+ 第一次登录时，携带用户名密码，因为用户登录接口是开放在白名单里的，SpringSecurity直接放行，不会拦截

+ 会直接进入到UserController中，首先在Redis中通过用户名查询是否有用户信息，如果没有则到数据库中查询，如果数据库中查不到用户信息，或查到的用户是禁用状态，则抛出异常，通过全局异常处理，返回前端相应的提示信息。如果数据库中查到了，则先存入Redis缓存中，并进行下一步处理

+ 如果成功查到用户信息，则校验用户密码是否正确，不正确则返回

+ 正确则通过SecurityContextHolder保存该用户信息的安全上下文，基于ThreadLocal的工作方式，同时通过用户名，当前时间、配置文件设置的过期时间（7天过期）、加密算法、密钥生成token，返回给前端

+ 当然还会经过自己配置的Spring AOP日志切面记录日志在控制台与磁盘中

+ 

+ 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里；

+ 在之后的请求中，客户端每次向服务端请求资源的时候需要带着服务端签发的 Token（在http的header中添加一个叫Authorization的头，值为Bearer + JWT的token）

+ 在SpringSecurity中，我自定义权限拦截器JWT过滤器（过滤器实际上就是对web资源进行拦截，做一些处理后再交给下一个过滤器或servlet处理通常都是用来拦截request进行处理的，也可以对返回的response进行拦截处理，继承OncePerRequestFilter，他能够确保在一次请求只通过一次filter，而不需要重复执行。）

+ 在过滤器中首先获取请求头Authorization的内容，并且解析该请求头是否以Bearer开始，若是则获取相关token值，从token值中再获取用户名

+ 获取用户名后，继续根据用户名加载用户信息（和上述账号密码认证用同一套逻辑，即先从缓存中找，找不到就加载数据库）

+ 随后验证token是否过期

+ 随后同样在SecurityContextHolder保存该用户信息的安全上下文

+ 如果最后验证成功，则进行正常的业务逻辑，向客户端返回请求的数据。

    



如果没有携带token，则使用login方法

用户信息是通过缓存或数据库中查询，并封装成UserDetails对象

登录成功后将用户上下文信息存入SecurityContext中，并且生成Token返回。

```java
    @Override
    public String login(UsernameLoginParam param) {
        String username = param.getUsername();
        String password = param.getPassword();

        System.out.println(passwordEncoder.encode(password));

        String token = null;
        //密码需要客户端加密后传递,但是传递的仍然是明文
        UserDetails userDetails = loadUserByUsername(username);
        if (!passwordEncoder.matches(password, userDetails.getPassword())) {
            throw new BadCredentialsException("密码不正确");
        }
//            获取该用户的上下文信息
//            username和password被获得后封装到一个UsernamePasswordAuthenticationToken
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
//            围绕该用户建立安全上下文（security context）
        SecurityContextHolder.getContext().setAuthentication(authentication);
        token = jwtTokenUtil.generateToken(userDetails);
        return token;
    }

    @Override
    public UserDetails loadUserByUsername(String username) {
        BoyingUser user = getByUsername(username);
        return new BoyingUserDetails(user);
    }

    @Override
    public BoyingUser getByUsername(String username) {
        BoyingUser user = boyingUserCacheService.getUser(username);
        if (user != null) return user; //缓存里面有数据

        //根据用户名查询是否存在
        user = boyingUserMapper.selectByUsername(username);

        //不能给过于详细的错误提示！
        if (user == null) Asserts.fail("用户名或密码错误");

        //账号未启用
        if (user.getAdminDelete()) Asserts.fail("账号未启用,请联系管理员!");

        boyingUserCacheService.setUser(user);//将查询到的数据放入缓存中
        return user;
    }
```

## getCurrentUser()

```java
    @Override
    public BoyingUser getCurrentUser() {
//        获取之前登录存储的用户上下文信息
        //ThreadLocal
        SecurityContext ctx = SecurityContextHolder.getContext();
        Authentication auth = ctx.getAuthentication();
        BoyingUserDetails userDetails = (BoyingUserDetails) auth.getPrincipal();
        System.out.println(userDetails.getUser());
        return userDetails.getUser();
    }
```



## BoyingUserDetails

```java
/**
 * SpringSecurity需要的用户详情
 */
public class BoyingUserDetails implements UserDetails {
    private final BoyingUser user;

    public BoyingUserDetails(BoyingUser user) {
        this.user = user;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        //返回当前用户的角色
        return Arrays.asList(new SimpleGrantedAuthority("TEST"));
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUsername();
    }

    @Override
    public boolean isEnabled() {
        return user.getAdminDelete();
    }
}
```

## BoyingSecurityConfig

```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class BoyingSecurityConfig extends SecurityConfig {

    @Autowired
    private BoyingUserService boyingUserService;

    /**
     * 注解@Bean放在方法上，产生一个Bean并且交给Spring容器管理
     * 定义用户信息
     *
     * @return
     */
    @Bean
    public UserDetailsService userDetailsService() {
        //为UserDetailsService定义一个适用与boying-user组件的获取登录用户信息的方法
        return username -> boyingUserService.loadUserByUsername(username);
    }
    //不添加基于路径的动态权限控制
}
```

当有token时，过滤器会直接使用token进行登录：

```java
@Override
protected void doFilterInternal(HttpServletRequest request,
                                HttpServletResponse response,
                                FilterChain chain) throws ServletException, IOException
{
    //请求头有字段Authorization，并且以‘Bearer ’开头
    String authHeader = request.getHeader(this.tokenHeader);
    if (authHeader != null && authHeader.startsWith(this.tokenHead))
    {
        String authToken = authHeader.substring(this.tokenHead.length());// The part after "Bearer "
        String username = jwtTokenUtil.getUserNameFromToken(authToken);
        LOGGER.info("checking username:{}", username);
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null)
        {
            //SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限）
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);
            //验证用户名和是否已过期
            if (jwtTokenUtil.validateToken(authToken, userDetails))
            {
                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                LOGGER.info("authenticated user:{}", username);
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }
    }
    chain.doFilter(request, response);
}
```



## 用户信息

登录时，若缓存没有信息，则存入Redis中（用户名，用户信息）（手机号，用户信息）

```java
//boyingUserCacheService.setUser(user);//将查询到的数据放入缓存中

@Override
    public void setUser(BoyingUser user) {
        String key = REDIS_DATABASE + ":" + REDIS_KEY_USER + ":" + user.getUsername();
        String key2 = REDIS_DATABASE + ":" + REDIS_KEY_USER + ":" + user.getPhone();
//        设置两条,能通过手机号,用户名查到该用户
        redisService.set(key, user, REDIS_EXPIRE);
        redisService.set(key2, user, REDIS_EXPIRE);
    }
```

更新个人信息时，删除缓存

```java
    @Override
    public void delUser(int userId) {
//        确保全局不会redis缓存key混乱
        BoyingUser user = boyingUserMapper.selectByPrimaryKey(userId);
        if (user != null) {
            String key = REDIS_DATABASE + ":" + REDIS_KEY_USER + ":" + user.getUsername();
            String key2 = REDIS_DATABASE + ":" + REDIS_KEY_USER + ":" + user.getPhone();
            redisService.del(key);
            redisService.del(key2);
        }
    }
```





# JwtTokenUtil

用于生成和解析JWT token的工具类

```yml
jwt:
  tokenHeader: Authorization #JWT存储的请求头
  secret: boying-user-secret #JWT加解密使用的密钥
  expiration: 604800 #JWT的超期限时间(60*60*24*7) 7天过期
  tokenHead: 'Bearer '  #JWT负载中拿到开头
```

```java
public class JwtTokenUtil
{
    private static final String CLAIM_KEY_USERNAME = "sub";
    private static final String CLAIM_KEY_CREATED = "created";
    @Value("${jwt.secret}")
    private String secret;
    @Value("${jwt.expiration}")
    private Long expiration;
    @Value("${jwt.tokenHead}")
    private String tokenHead;
    
    /**
     * 根据登录用户信息生成token
     */
    public String generateToken(UserDetails userDetails)
    {
        Map<String, Object> claims = new HashMap<>();
        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());
        claims.put(CLAIM_KEY_CREATED, new Date());
        return generateToken(claims);
    }
    /**
     * 根据负责生成JWT的token
     */
    private String generateToken(Map<String, Object> claims)
    {
        return Jwts.builder()
                .setClaims(claims)
                .setExpiration(generateExpirationDate())
                .signWith(SignatureAlgorithm.HS512, secret)
                .compact();
    }
    /**
     * 生成token的过期时间
     */
    private Date generateExpirationDate()
    {
        return new Date(System.currentTimeMillis() + expiration * 1000);
    }
    
    
    /**
     * 从token中获取登录用户名
     */
    public String getUserNameFromToken(String token)
    {
        String username;
        try
        {
            Claims claims = getClaimsFromToken(token);
            username = claims.getSubject();
        }
        catch (Exception e)
        {
            username = null;
        }
        return username;
    }
    
    
    
    
    /**
     * 验证token是否还有效
     *
     * @param token       客户端传入的token
     * @param userDetails 从数据库中查询出来的用户信息
     */
    public boolean validateToken(String token, UserDetails userDetails)
    {
        String username = getUserNameFromToken(token);
        return username.equals(userDetails.getUsername()) && !isTokenExpired(token);
    }

    /**
     * 判断token是否已经失效
     */
    private boolean isTokenExpired(String token)
    {
        Date expiredDate = getExpiredDateFromToken(token);
        return expiredDate.before(new Date());
    }
}

```



# SecurityConfig

对SpringSecurity的配置的扩展，支持自定义白名单资源路径和查询用户逻辑，其他的所有类都是为它服务的

```java
public class SecurityConfig extends WebSecurityConfigurerAdapter
{
    //@Autowired(required=false)：表示忽略当前要注入的bean，如果有直接注入，没有跳过，不会报错。
    @Autowired(required = false)
    private DynamicSecurityService dynamicSecurityService;
    
    // 用于配置需要拦截的url路径、jwt过滤器及出异常后的处理器；
     @Override
    protected void configure(HttpSecurity httpSecurity) throws Exception
    {
        //不需要保护的资源路径允许访问
        for (String url : ignoreUrlsConfig().getUrls())
        {
            registry.antMatchers(url).permitAll();
        }
        
        //允许跨域请求的OPTIONS请求
        registry.antMatchers(HttpMethod.OPTIONS).permitAll();
        
        // 任何请求需要身份认证
        registry
                .accessDeniedHandler(restfulAccessDeniedHandler())// 无权限处理
                .authenticationEntryPoint(restAuthenticationEntryPoint())//未登录处理
                .addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);//权限拦截器JWT过滤器
    }
    @Bean
    public IgnoreUrlsConfig ignoreUrlsConfig()
    {
        return new IgnoreUrlsConfig();
    }
	/**
     * 当用户没有访问权限时,将调用该方法。是没有访问权限时的处理器，用于返回JSON格式的处理结果
     */
    @Bean
    public RestfulAccessDeniedHandler restfulAccessDeniedHandler()
    {
        return new RestfulAccessDeniedHandler();
    }
     /**
     * 当未登录或token失效时，返回JSON格式的结果
     *
     * @return
     */
    @Bean
    public RestAuthenticationEntryPoint restAuthenticationEntryPoint()
    {
        return new RestAuthenticationEntryPoint();
    }
    /**
     * 在用户名和密码校验前添加的过滤器，如果有jwt的token，会自行根据token信息进行登录。
     *
     * @return
     */
    @Bean
    public JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter()
    {
        return new JwtAuthenticationTokenFilter();
    }
    
    
    
    /**
     * 用于配置UserDetailsService及PasswordEncoder
     */
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception
    {
        //UserDetailsService:SpringSecurity定义的核心接口，用于根据用户名获取用户信息，需要自行实现
        auth.userDetailsService(userDetailsService())
                .passwordEncoder(passwordEncoder());
    }
    /**
     * SpringSecurity定义的用于对密码进行编码及比对的接口，目前使用的是BCryptPasswordEncoder
     */
    @Bean
    public PasswordEncoder passwordEncoder()
    {
        return new BCryptPasswordEncoder();
    }
}
```

## IgnoreUrlsConfig

处理SecurityConfig中的白名单，用于不需要保护的资源路径允许访问

```yml
secure:
  ignored:
    urls: #安全路径白名单
      - /swagger-ui.html
      - /user/**
      - /home/**
```

```java
/**
 * 用于配置白名单资源路径
 * 将大量的参数配置在 application.yml 文件中，
 * 通过 @ConfigurationProperties 注解，我们可以方便的获取这些参数值
 */
@Getter
@Setter
@ConfigurationProperties(prefix = "secure.ignored")
public class IgnoreUrlsConfig
{

    private List<String> urls = new ArrayList<>();

}
```

## RestfulAccessDeniedHandler

```java
/**
 * 处理SecurityConfig中没有权限访问时自定义返回结果，返回403相关信息
 * 自定义返回结果：没有权限访问时
 * 返回403相关信息
 */
public class RestfulAccessDeniedHandler implements AccessDeniedHandler
{
    @Override
    public void handle(HttpServletRequest request,
                       HttpServletResponse response,
                       AccessDeniedException e) throws IOException, ServletException
    {     response.getWriter().println(JSONUtil.parse(CommonResult.forbidden(e.getMessage())));
        response.getWriter().flush();
    }
}
```

## RestAuthenticationEntryPoint

```java
/**
 * 自定义返回结果：未登录或登录过期
 * 即返回401相关信息
 */
public class RestAuthenticationEntryPoint implements AuthenticationEntryPoint
{
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException
    {
        response.setHeader("Access-Control-Allow-Origin", "*");
        response.setHeader("Cache-Control", "no-cache");
        response.setCharacterEncoding("UTF-8");
        response.setContentType("application/json");
        response.getWriter().println(JSONUtil.parse(CommonResult.unauthorized(authException.getMessage())));
        response.getWriter().flush();
    }
}
```

## JwtAuthenticationTokenFilter

处理SecurityConfig，在用户名和密码校验前添加的过滤器，如果请求中有jwt的token且有效，会取出token中的用户名，然后调用SpringSecurity的API进行登录操作。

```java
/**
 * JWT登录授权过滤器
 
  tokenHeader: Authorization #JWT存储的请求头
  tokenHead: 'Bearer '  #JWT负载中拿到开头
 */
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter
{
 
    /**
     * SpringSecurity定义的核心接口，用于根据用户名获取用户信息
     */
    @Autowired
    private UserDetailsService userDetailsService;
    @Autowired
    private JwtTokenUtil jwtTokenUtil;
    @Value("${jwt.tokenHeader}")
    private String tokenHeader;
    @Value("${jwt.tokenHead}")
    private String tokenHead;

     @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException
    {
        //请求头有字段Authorization，并且以‘Bearer ’开头
        String authHeader = request.getHeader(this.tokenHeader);
        if (authHeader != null && authHeader.startsWith(this.tokenHead))
        {
            String authToken = authHeader.substring(this.tokenHead.length());// The part after "Bearer "
            String username = jwtTokenUtil.getUserNameFromToken(authToken);
            LOGGER.info("checking username:{}", username);
            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null)
            {
                //SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限）
                //这里首先从缓存中获取用户信息和用户权限
                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);
                //验证用户名和是否已过期
                if (jwtTokenUtil.validateToken(authToken, userDetails))
                {
                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    LOGGER.info("authenticated user:{}", username);
                    /*
                    SecurityContextHolder使用了ThreadLocal机制来保存每个使用者的安全上下文。
                    这意味着，只要针对某个使用者的逻辑执行都是在同一个线程中进行，即使不在各个方法之间以参数的形式传递其安全上下文，
                    各个方法也能通过SecurityContextHolder工具获取到该安全上下文。只要在处理完当前使用者的请求之后注意清除ThreadLocal中的安全上下文
                     */
                    SecurityContextHolder.getContext().setAuthentication(authentication);
                }
            }
        }
        chain.doFilter(request, response);
    }
}
```



## BoyingSecurityConfig

实现了对SecurityConfig的扩展，获取用户信息和用户拥有的权限

```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class BoyingSecurityConfig extends SecurityConfig
{

    @Autowired
    private UmsAdminService adminService;
    @Autowired
    private UmsResourceService resourceService;

    //实现security模块的该方法，根据用户名获取用户信息
    @Bean
    public UserDetailsService userDetailsService()
    {
        //获取登录用户信息
        return username -> adminService.loadUserByUsername(username);
        /*
        @Override
        public UserDetails loadUserByUsername(String username)
        {
            //获取用户信息
            AdminUser AdminUser = getAdminByUsername(username);
            if (AdminUser != null)
            {
                List<AdminResource> resourceList = getResourceList(AdminUser.getId());
                return new AdminUserDetails(AdminUser, resourceList);
            }
            throw new UsernameNotFoundException("用户名或密码错误");
        }
        */
    }

    //    加载所有的资源 资源路径url,资源路径值(自定义为了 id:name )
    @Bean
    public DynamicSecurityService dynamicSecurityService()
    {
        return new DynamicSecurityService()
        {
            @Override
            public Map<String, ConfigAttribute> loadDataSource()
            {
                Map<String, ConfigAttribute> map = new ConcurrentHashMap<>();
                List<AdminResource> resourceList = resourceService.listAll();
                for (AdminResource resource : resourceList)
                {
                    map.put(resource.getUrl(), new org.springframework.security.access.SecurityConfig(resource.getId() + ":" + resource.getName()));
                }
                return map;
            }
        };
    }
}
```

## UserDetails

SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限）

```java
public interface UserDetails extends Serializable 
{
    Collection<? extends GrantedAuthority> getAuthorities();

    String getPassword();

    String getUsername();

    boolean isEnabled();
}
```

## AdminUserDetails

```java
/**
 * SpringSecurity需要的用户详情
 */
public class AdminUserDetails implements UserDetails
{
    private final AdminUser adminUser;
    private final List<AdminResource> resourceList;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities()
    {
        //返回当前用户拥有的资源权限
        return resourceList.stream()
                .map(AdminResource -> new SimpleGrantedAuthority(AdminResource.getId() + ":" + AdminResource.getName()))
                .collect(Collectors.toList());
    }
    
     @Override
    public String getPassword()
    {
        return adminUser.getPassword();
    }

    @Override
    public String getUsername()
    {
        return adminUser.getUsername();
    }

    @Override
    public boolean isEnabled()
    {
        return adminUser.getStatus();
    }

}
```



# 基于路径的动态权限控制

当有动态权限业务类时在FilterSecurityInterceptor过滤器前添加我们的动态权限过滤器。这里在创建动态权限相关对象时，还使用了@ConditionalOnBean这个注解，当没有动态权限业务类时就不会创建动态权限相关对象，实现了有动态权限控制和没有这两种情况的兼容。

例如admin中有DynamicSecurityService这个Bean对象，则所有的动态权限控制可用

```java
public class SecurityConfig extends WebSecurityConfigurerAdapter
{
    @Autowired(required = false)
    private DynamicSecurityService dynamicSecurityService;
    
     @Override
    protected void configure(HttpSecurity httpSecurity) throws Exception
    {
        //有动态权限配置时添加动态权限校验过滤器
        if (dynamicSecurityService != null)
        {
            //在指定的beforeFilter之前加入filter
            registry.and().addFilterBefore(dynamicSecurityFilter(), 	FilterSecurityInterceptor.class);
        }
    }
    

    
    @ConditionalOnBean(name = "dynamicSecurityService")
    @Bean
    public DynamicSecurityFilter dynamicSecurityFilter()
    {
        return new DynamicSecurityFilter();
    }
    
    //使用了@ConditionalOnBean这个注解,当没有动态权限业务类时就不会创建动态权限相关对象，实现了有动态权限控制和没有这两种情况的兼容。
    @ConditionalOnBean(name = "dynamicSecurityService")
    @Bean
    public DynamicAccessDecisionManager dynamicAccessDecisionManager()
    {
        return new DynamicAccessDecisionManager();
    }


    @ConditionalOnBean(name = "dynamicSecurityService")
    @Bean
    public DynamicSecurityFilter dynamicSecurityFilter()
    {
        return new DynamicSecurityFilter();
    }

    @ConditionalOnBean(name = "dynamicSecurityService")
    @Bean
    public DynamicSecurityMetadataSource dynamicSecurityMetadataSource()
    {
        return new DynamicSecurityMetadataSource();
    }
}
```

## DynamicSecurityFilter
动态权限过滤器，用于实现基于路径的动态权限过滤。

首先我们需要创建一个过滤器，用于实现动态权限控制，这里需要注意的是`doFilter`方法，对于OPTIONS请求直接放行，否则前端调用会出现跨域问题。对于配置在`IgnoreUrlsConfig`中的白名单路径我也需要直接放行，所有的鉴权操作都会在`super.beforeInvocation(fi)`中进行。

```java
/**
 * 动态权限过滤器，用于实现基于路径的动态权限过滤
 */
public class DynamicSecurityFilter extends AbstractSecurityInterceptor implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        FilterInvocation fi = new FilterInvocation(servletRequest, servletResponse, filterChain);
        //OPTIONS请求直接放行
        if(request.getMethod().equals(HttpMethod.OPTIONS.toString())){
            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
            return;
        }
        //白名单请求直接放行
        PathMatcher pathMatcher = new AntPathMatcher();
        for (String path : ignoreUrlsConfig.getUrls()) {
            if(pathMatcher.match(path,request.getRequestURI())){
                fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
                return;
            }
        }
        //此处会调用AccessDecisionManager中的decide方法进行鉴权操作
        InterceptorStatusToken token = super.beforeInvocation(fi);
        try {
            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());
        } finally {
            super.afterInvocation(token, null);
        }
    }
}
```

## DynamicSecurityMetadataSource
自己实现SecurityMetadataSource接口的getAttributes方法，用于获取当前访问路径所需资源。

```java
/**
 * 动态权限数据源，用于获取动态权限规则
 */
public class DynamicSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {
	//后台资源规则被缓存在了一个Map对象之中
    private static Map<String, ConfigAttribute> configAttributeMap = null;
    
    //动态权限相关业务类，自定义的一个动态权限业务接口，其主要用于加载所有的后台资源规则。
    @Autowired
    private DynamicSecurityService dynamicSecurityService;

    @PostConstruct
    public void loadDataSource() {
        configAttributeMap = dynamicSecurityService.loadDataSource();
    }

    //所以当后台资源发生变化时，我们需要清空缓存的数据
    public void clearDataSource() {
        configAttributeMap.clear();
        configAttributeMap = null;
    }

    @Override
    public Collection<ConfigAttribute> getAttributes(Object o) throws IllegalArgumentException {
        if (configAttributeMap == null) this.loadDataSource();
        List<ConfigAttribute>  configAttributes = new ArrayList<>();
        //获取当前访问的路径
        String url = ((FilterInvocation) o).getRequestUrl();
        String path = URLUtil.getPath(url);
        PathMatcher pathMatcher = new AntPathMatcher();
        Iterator<String> iterator = configAttributeMap.keySet().iterator();
        //获取访问该路径所需资源
        while (iterator.hasNext()) {
            String pattern = iterator.next();
            if (pathMatcher.match(pattern, path)) {
                configAttributes.add(configAttributeMap.get(pattern));
            }
        }
        // 未设置操作请求权限，返回空集合
        return configAttributes;
    }
}
```

## DynamicAccessDecisionManager

实现AccessDecisionManager接口来实现权限校验，对于没有配置资源的接口我们直接允许访问，对于配置了资源的接口，我们把访问所需资源和用户拥有的资源进行比对，如果匹配则允许访问。

```java
/**
 * 动态权限决策管理器，用于判断用户是否有访问权限
 */
public class DynamicAccessDecisionManager implements AccessDecisionManager {

    @Override
    public void decide(Authentication authentication, Object object,
                       Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException {
        // 当接口未被配置资源时直接放行
        if (CollUtil.isEmpty(configAttributes)) {
            return;
        }
        Iterator<ConfigAttribute> iterator = configAttributes.iterator();
        while (iterator.hasNext()) {
            ConfigAttribute configAttribute = iterator.next();
            //将访问所需资源或用户拥有资源进行比对
            String needAuthority = configAttribute.getAttribute();
            for (GrantedAuthority grantedAuthority : authentication.getAuthorities()) {
                if (needAuthority.trim().equals(grantedAuthority.getAuthority())) {
                    return;
                }
            }
        }
        throw new AccessDeniedException("抱歉，您没有访问权限");
    }
}
```

## DynamicSecurityService

动态权限相关业务类，自定义的一个动态权限业务接口，其主要用于加载所有的后台资源规则。

```java
/**
 * 动态权限相关业务类
 */
public interface DynamicSecurityService {
    /**
     * 加载资源ANT通配符和资源对应MAP
     */
    Map<String, ConfigAttribute> loadDataSource();
}
```



## BoyingSecurityConfig

此类是admin中的类

当有动态权限业务类时在FilterSecurityInterceptor过滤器前添加我们的动态权限过滤器。这里在创建动态权限相关对象时，还使用了@ConditionalOnBean这个注解，当没有动态权限业务类时就不会创建动态权限相关对象，实现了有动态权限控制和没有这两种情况的兼容。

```java
public class BoyingSecurityConfig extends SecurityConfig
{
    //    加载所有的资源 资源路径url,资源路径值(自定义为了 id:name )
    @Bean
    public DynamicSecurityService dynamicSecurityService()
    {
        return new DynamicSecurityService()
        {
            @Override
            public Map<String, ConfigAttribute> loadDataSource()
            {
                Map<String, ConfigAttribute> map = new ConcurrentHashMap<>();
                List<AdminResource> resourceList = resourceService.listAll();
                for (AdminResource resource : resourceList)
                {
                    map.put(resource.getUrl(), new org.springframework.security.access.SecurityConfig(resource.getId() + ":" + resource.getName()));
                }
                return map;
            }
        };
    }
}
```

## AdminUserDetails

```java
public class AdminUserDetails implements UserDetails
{
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities()
    {
        //返回当前用户拥有的资源权限
        return resourceList.stream()
                .map(AdminResource -> new SimpleGrantedAuthority(AdminResource.getId() + ":" + AdminResource.getName()))
                .collect(Collectors.toList());
    }
}
```



# AOP优化

给获取用户信息和获取用户的资源信息这两个操作添加缓存操作，当我们修改用户信息和资源信息时都需要删除缓存中的数据

## RedisCacheAspect

```java
/**
 * Redis缓存切面，防止Redis宕机影响正常业务逻辑
 * 定义一个切面，在相关缓存业务类上面应用，在它的环绕通知中直接处理掉异常，保障后续操作能执行。
 * 因为作为缓存，我们所希望的是，如果Redis宕机了，我们的业务逻辑不会有影响。
 * 要保证缓存业务类中的方法执行不影响正常的业务逻辑，就需要在所有方法中添加`try catch`逻辑。
 * 使用AOP，我们可以在一个地方写上`try catch`逻辑，然后应用到所有方法上去。
 */
@Aspect
@Component
@Order(2)
public class RedisCacheAspect
{
    private static final Logger LOGGER = LoggerFactory.getLogger(RedisCacheAspect.class);

    @Pointcut("execution(public * com.tongji.boying.service.*CacheService.*(..))")
    public void cacheAspect()
    {
    }

    @Around("cacheAspect()")
    public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable
    {
        Signature signature = joinPoint.getSignature();
        MethodSignature methodSignature = (MethodSignature) signature;
        Method method = methodSignature.getMethod();
        Object result = null;
        try
        {
            result = joinPoint.proceed();
        }
        catch (Throwable throwable)
        {
            //有CacheException注解的方法需要抛出异常
            if (method.isAnnotationPresent(CacheException.class))
            {
                throw throwable;
            }
            else
            {
                LOGGER.error(throwable.getMessage());
            }
        }
        return result;
    }
}
```

## CacheException

自定义注解，有该注解的缓存方法会抛出异常。例如验证码存储，如果我们的Redis宕机了，我们的验证码存储接口需要的是报错，而不是返回执行成功。

```java
/**
 * 自定义注解，有该注解的缓存方法会抛出异常
 */
@Documented
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface CacheException
{
}
```

## RedisConfig

```java
/**
 * Redis配置类
 */
@EnableCaching
@Configuration
public class RedisConfig extends BaseRedisConfig
{

}
```

# 前后端分离跨域问题

CORS全称Cross-Origin Resource Sharing，意为跨域资源共享。当一个资源去访问另一个不同域名或者同域名不同端口的资源时，就会发出跨域请求。如果此时另一个资源不允许其进行跨域资源访问，那么访问的那个资源就会遇到跨域问题。

## 添加GlobalCorsConfig配置文件来允许跨域访问。

```java
/**
 * 全局跨域配置
 */
@Configuration
public class GlobalCorsConfig {

    /**
     * 允许跨域调用的过滤器
     */
    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        //允许所有域名进行跨域调用
        config.addAllowedOrigin("*");
        //允许跨越发送cookie
        config.setAllowCredentials(true);
        //放行全部原始头信息
        config.addAllowedHeader("*");
        //允许所有请求方法跨域调用
        config.addAllowedMethod("*");
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return new CorsFilter(source);
    }
}
```

此时发现，需要登录认证的/admin/info接口的OPTIONS请求无法通过认证，那是因为复杂的跨越请求需要先进行一次OPTIONS请求进行预检，我们的应用整合了SpringSecurity，对OPTIONS请求并没有放开登录认证。

## 设置SpringSecurity允许OPTIONS请求访问

在SecurityConfig类的configure(HttpSecurity httpSecurity)方法中添加如下代码。

```java
.antMatchers(HttpMethod.OPTIONS)//跨域请求会先进行一次options请求
.permitAll()
```

## 一次完整的跨域请求

### 先发起一次OPTIONS请求进行预检

**请求头信息**

```text
Access-Control-Request-Headers: content-type
Access-Control-Request-Method: POST
Origin: http://localhost:8090
Referer: http://localhost:8090/
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36
```

**响应头信息**

```text
Access-Control-Allow-Credentials: true
Access-Control-Allow-Headers: content-type
Access-Control-Allow-Methods: POST
Access-Control-Allow-Origin: http://localhost:8090
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Content-Length: 0
Date: Sat, 27 Jul 2019 13:40:32 GMT
Expires: 0
Pragma: no-cache
Vary: Origin, Access-Control-Request-Method, Access-Control-Request-Headers
X-Content-Type-Options: nosniff
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
```

- 请求成功返回状态码为200

### 发起真实的跨域请求