---
title: boying-admin技术说明
date: 2021-01-10
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 博影项目子模块——boying-admin的结构，包括权限管理的介绍、AOP优化等
categories: 博影项目笔记
tags:

  - 项目
  - 权限管理
  - AOP





---



# 背景知识

## 权限系统

权限系统就是：明确操作人员可在平台内能做什么。即什么样的人，可以做什么样的事，这并不难理解，我们的用户是所有可以登录该平台的人员。

“用户管理”、“角色管理”、“权限管理”

RBAC即：权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。

用户与角色一一对应，一个用户对应一个角色；同一个角色可对应多个后台操作页面

RBAC结构可通过“角色”搭建用户与权限之间的关系，可在创建角色时绑定相应权限，再匹配到用户，可提高整体的效率以及稳定性。

## 认证

用户认证通过后，将用户信息保存在会话中，如token等。基于JWT令牌，会话通过token保存。认证是保护用户身份的合法性。

## 授权

更细粒度的对隐私数据进行划分。授权是用户认证通过根据用户的权限来控制用户访问资源的过程。



## RBAC

“用户-角色-权限”管理是 **“访问控制”** 的一种实现方式，更为专业的叫法为 **RBAC**（Role-Based Access Control），即基于角色的权限访问控制。

权限的三种粒度：**菜单权限、操作/功能权限、数据权限**。

## 用户管理

- **用户信息：** 显示用户的基本信息（昵称、联系方式、角色、部门等）
- **组织架构：** 显示、配置（增删改）组织架构，一般为树结构
- **用户操作：** 为用户分配角色（多对多）、组织架构（多对多），删除用户
- **用户黑白名单：** 对特殊用户进行特别控制

## 角色管理

- **角色信息：** 显示角色的基本信息（名称、权限等）
- **角色操作：** 根据需要增删角色、为角色分配权限（多对多，按不同粒度分配，并实现权限的互斥性检验）

## 权限管理

权限一般有如下三种粒度：

- **菜单权限：** 访问某一菜单（页面、路由）的权限
- **操作/功能权限：** 进行某一操作或使用某一功能的权限（如删除用户的权限）
- **数据权限：** 访问某种数据（表、字段）的权限，或对可操作数据量的控制

## 技术要点

- 用户、角色、权限、组织架构表结构设计
- 用户身份验证、授权、会话管理，用户信息的加密存储
- 不同粒度权限的具体实现



# 权限管理

权限管理在后端项目中主要体现在对接口访问权限的控制，在前端项目中主要体现在对菜单访问权限的控制

如何结合Vue来实现菜单的动态权限控制。

## 菜单管理

可以实现对后台管理系统左侧菜单的管理，支持更换图标、更换名称、控制菜单显示和排序（控制其隐藏显示及更换图片名称和排序，目前仅支持二级菜单）

菜单管理用于控制前端菜单的显示和隐藏

- 查看菜单列表，可以控制隐藏显示及删除；
- 添加及编辑菜单，可以更改菜单的基本属性，不过只能添加前端项目`路由中定义`的菜单，并且`前端名称`要与前端项目中定义的`路由名称`一致；
- 菜单排序，给菜单设置排序后，菜单将按照设置的排序降序进行显示。

## 资源管理

资源管理用来控制后端接口的访问权限。

后台资源表，用于控制后台用户可以访问的接口，使用了Ant路径的匹配规则，可以使用通配符定义一系列接口的权限。

实现了基于访问路径的后台动态权限控制，控制的权限可以精确到接口级别

所谓资源就是后台的接口，可以是单个接口，也可以是一系列接口的集合。这里我们使用了基于Ant的路径匹配，当后台用户访问某个接口时，如果这个后台用户分配了该资源就可以访问，否则无法访问。默认情况下，如果你没有对某个接口配置资源，则该资源直接允许访问。

例子：将订单相关菜单开放给商品管理员，但是并没有给他分配订单相关的资源；能进入那个菜单，但是由于没有给商品管理员分配订单模块相关后台资源，所以当商品管理员访问订单模块时会提示没有相关权限。

- 查看资源列表，目前的资源是按控制器级别配置的，即一个控制器中所有的接口定义为一个资源，也可以配置到接口级别；
- 添加及编辑资源，这里我们添加了一个资源分类的概念，便于以后的资源分配；

## 角色管理

可以自定义角色，并为角色分配菜单和资源；

用于对后台用户角色进行管理，我们可以给角色分配指定的菜单和资源，这样被分配了角色的后台用户就可以访问这些菜单和资源了。

## 后台用户管理

可以对后台用户进行管理并分配角色，支持分配多个角色。

用于对后台用户进行管理，直接修改信息（包括修改密码）及分配角色





# config

## AdminUserDetails

SpringSecurity需要的用户详情

```java
public class AdminUserDetails implements UserDetails
{
    private final AdminUser adminUser;
    private final List<AdminResource> resourceList;

    public AdminUserDetails(AdminUser AdminUser, List<AdminResource> resourceList)
    {
        this.adminUser = AdminUser;
        this.resourceList = resourceList;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities()
    {
        //返回当前用户拥有的资源权限
        return resourceList.stream()
                .map(AdminResource -> new SimpleGrantedAuthority(AdminResource.getId() + ":" + AdminResource.getName()))
                .collect(Collectors.toList());
    }
    
    //根据status标识该账号是否可用
     @Override
    public boolean isEnabled()
    {
        return adminUser.getStatus();
    }
}
```

## BoyingSecurityConfig

### userDetailsService()

根据用户名获取登录用户信息

### dynamicSecurityService()

要实现动态路径控制则必须实现该方法,注入`Bean`,目的是加载所有的资源,这通过一个Map实现,存储资源路径url,资源路径值(自定义为了 id:name )



## GlobalCorsConfig

全局跨域相关配置

## MyBatisConfig

MyBatis相关配置，控制dao或者mapper文件扫描位置

## SwaggerConfig

对boying-common的swagger相关组件进行自定义配置。Swagger API文档相关配置，主要是api扫描位置以及标题等



# 优化

因为每次访问接口进行权限校验时都会从数据库中去查询用户信息。最近对这个问题进行了优化，通过Redis+AOP解决了该问题，下面来讲下我的优化思路。

在`mall-security`模块中有一个过滤器，当用户登录后，请求会带着token经过这个过滤器。这个过滤器会根据用户携带的token进行类似免密登录的操作，其中有一步会从数据库中查询登录用户信息，下面是这个过滤器类的代码。



```java
/**
 * JWT登录授权过滤器
 */
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException {
        String authHeader = request.getHeader(this.tokenHeader);
        if (authHeader != null && authHeader.startsWith(this.tokenHead)) {
            String authToken = authHeader.substring(this.tokenHead.length());// The part after "Bearer "
            String username = jwtTokenUtil.getUserNameFromToken(authToken);
            LOGGER.info("checking username:{}", username);
            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                //此处会从数据库中获取登录用户信息
                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);
                if (jwtTokenUtil.validateToken(authToken, userDetails)) {
                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    LOGGER.info("authenticated user:{}", username);
                    SecurityContextHolder.getContext().setAuthentication(authentication);
                }
            }
        }
        chain.doFilter(request, response);
    }
}
```

当我们登录后访问任意接口时，控制台会打印如下日志，表示会从数据库中查询用户信息和用户所拥有的资源信息，每次访问接口都触发这种操作，有的时候会带来一定的性能问题。

对于上面的问题，最容易想到的就是把用户信息和用户资源信息存入到Redis中去，避免频繁查询数据库

首先我们需要对Spring Security中获取用户信息的方法添加缓存

主要是获取用户信息和获取用户的资源信息这两个操作，接下来我们需要给这两个操作添加缓存操作，这里使用的是RedisTemple的操作方式。当查询数据时，先去Redis缓存中查询，如果Redis中没有，再从数据库查询，查询到以后在把数据存储到Redis中去。

```java
	@Override
    public List<UmsResource> getResourceList(Long adminId) {
        //先从缓存中获取数据
        List<UmsResource> resourceList = adminCacheService.getResourceList(adminId);
        if(CollUtil.isNotEmpty(resourceList)){
            return  resourceList;
        }
        //缓存中没有从数据库中获取
        resourceList = adminRoleRelationDao.getResourceList(adminId);
        if(CollUtil.isNotEmpty(resourceList)){
            //将数据库中的数据存入缓存中
            adminCacheService.setResourceList(adminId,resourceList);
        }
        return resourceList;
    }
```

因为作为缓存，我们所希望的是，如果Redis宕机了，我们的业务逻辑不会有影响，而使用Spring Cache来实现的话，当Redis宕机以后，用户的登录等种种操作就会都无法进行了。

由于我们把用户信息和用户资源信息都缓存到了Redis中，所以当我们修改用户信息和资源信息时都需要删除缓存中的数据，具体什么时候删除，查看缓存业务类的注释即可。

经过上面的一系列优化之后，性能问题解决了。但是引入新的技术之后，新的问题也会产生，比如说当Redis宕机以后，我们直接就无法登录了，下面我们使用AOP来解决这个问题。

## 使用AOP处理缓存操作异常

要保证缓存业务类中的方法执行不影响正常的业务逻辑，就需要在所有方法中添加`try catch`逻辑。使用AOP，我们可以在一个地方写上`try catch`逻辑，然后应用到所有方法上去。试想下，我们如果又多了几个缓存业务类，只要配置下切面即可，这波操作多方便！

## RedisCacheAspect

首先我们先定义一个切面，在相关缓存业务类上面应用，在它的环绕通知中直接处理掉异常，保障后续操作能执行。

```java
/**
 * Redis缓存切面，防止Redis宕机影响正常业务逻辑
 */
@Aspect
@Component
@Order(2)
public class RedisCacheAspect {
    private static Logger LOGGER = LoggerFactory.getLogger(RedisCacheAspect.class);

    @Pointcut("execution(public * com.macro.mall.portal.service.*CacheService.*(..)) || execution(public * com.macro.mall.service.*CacheService.*(..))")
    public void cacheAspect() {
    }

    @Around("cacheAspect()")
    public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable {
        Object result = null;
        try {
            result = joinPoint.proceed();
        } catch (Throwable throwable) {
            LOGGER.error(throwable.getMessage());
        }
        return result;
    }

}
```