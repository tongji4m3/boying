---
title: boying-user技术说明
date: 2021-01-09
author: tongji4m3
top: false
cover: false
coverImg: /images/1.jpg
toc: true
mathjax: false
summary: 博影项目子模块——boying-user的结构，包括expain与索引优化、Jmeter与Nginx等
categories: 博影项目笔记
tags:

  - 项目
  - expain
  - Nginx




---



# 涉及的查询

## 注册

查看用户是否存在

```sql
select count(*)
    from boying_user
    where username = #{username} or phone = #{telephone}
```

## 根据用户名查询

```sql
select
<include refid="Base_Column_List" />
from boying_user
where username = #{username}
```

## 根据手机号查询

```sql
select
<include refid="Base_Column_List" />
from boying_user
where phone = #{telephone}
```

## 菜单查询

```sql
select
    <include refid="Base_Column_List"/>
    from boying_category
    where admin_delete = 0
    order by weight desc
```

## 演出查询

```sql
select
    <include refid="Base_Column_List"/>
    from boying_show
    <where>
        <if test="categoryId != null and categoryId != 0">
            category_id = #{categoryId}
        </if>
        <if test="keyword != null and keyword != ''">
            and name like concat('%',#{keyword,jdbcType=VARCHAR},'%')
        </if>
        <if test="city != null and city != '' and city != '全国'">
            and city = #{city}
        </if>
        <if test="startDay != null and endDay != null">
            and start_time
            between #{startDay} and #{endDay}
        </if>
    </where>
    <if test="sort == null">
        order by weight desc
    </if>
    <if test="sort == 0">
        order by weight desc
    </if>
    <if test="sort == 1">
        order by START_TIME asc
    </if>
    <if test="sort == 2">
        order by START_TIME desc
    </if>
    <if test="sort == 3">
        order by MIN_PRICE asc
    </if>
    <if test="sort == 4">
        order by MIN_PRICE desc
    </if>
    <if test="sort == 5">
        order by MAX_PRICE asc
    </if>
    <if test="sort == 6">
        order by MAX_PRICE desc
    </if>
</select>
```

## 演出座次查询

```sql
select
<include refid="Base_Column_List"/>
from boying_seat
where show_id = #{showId}
```

## 查看该用户对该演出是否下单过

```sql
select count(*)
from boying_order
where user_id = #{userId}
  and show_id = #{showId}
  and status != 3
```

## 订单条件查询

```sql
select
<include refid="Base_Column_List"/>
from boying_order
where user_id = #{userId} and user_delete != 1
<if test="status != null and status != 0">
    and status = #{status}
</if>
<if test="name != null and name != ''">
    and show_id in
    (select id from boying_show where name like concat('%',#{name},'%')
</if>
```

## 查看并减库存

```sql
update boying_stock
set stock = stock - #{ticketCount}
where id = #{seatId}
  and stock >= #{ticketCount}
```

## 增加库存

```sql
update boying_stock
set stock = stock + #{ticketCount}
where id = #{seatId}
```

## 根据演出座次获取活动信息

```sql
select
<include refid="Base_Column_List"/>
from boying_promo
where seat_id = #{seatId,jdbcType=INTEGER}
```

# expain与索引优化

## 用户信息

优化前：

![image-20210216153841728](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210216153841728.png)

虽然username、phone都是唯一的，但是只添加普通索引，不添加唯一索引

![image-20210216154531210](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/image-20210216154531210.png)

```sql
explain select count(*)
from boying_user
where username = 'tongji4m3' or phone = '15316162191';

explain select * from boying_user where username = 'tongji4m3';

explain select * from boying_user where phone = '15316162191';

ALTER  TABLE  `boying_user`  ADD  INDEX index_username (`username`);
ALTER  TABLE  `boying_user`  ADD  INDEX index_phone (`phone`);

drop index index_name on boying_user;
show indexes from boying_user;
```

其实上述语句等价于

```sql
select count(*) from boying_user where username = 'tongji4m3'
union
select count(*) from boying_user where phone = '15316162191';
```

## 订单信息

建立了复合索引(user_id,show_id)，这样在查看该用户对该演出是否下单过时可以用到两个索引，在单独查询用户的所有订单也可以用到索引（索引前缀）

```sql
explain select count(*) from boying_order where user_id = 1 and show_id = 1;

explain select * from boying_order where user_id = 1;

ALTER  TABLE  `boying_order`  ADD  INDEX index_order (user_id,show_id);

show indexes from boying_order;
```

# application.yml

## 多环境动态切换yml配置

在实际的的开发中，对于一个工程，经常会有多种环境配置，例如开发环境、测试环境、生产环境等。在不同的环境下，配置有可能是不一样的，比如接口地址、数据库连接配置等。为了避免频繁的修改配置文件，我们想要简便地切换各种环境配置。好在SpringBoot提供了这样的功能，可以很方便地切换不同场景下的配置。
	
对开发配置和生产环境做了配置。上面的配置是公共配置，下面我们分别配置了开发和生产的配置。`spring.profiles`表示配置的名称，`spring.profiles.active`表示要激活的环境，值和要切换的`spring.profiles`名称一致。默认激活的就是dev开发配置。
	
如果`spring.profiles.active`没有指定值，那么只会加载通用的配置。
	
工程打成jar包后，我们可以在运行的时候对配置进行选择，而不需要每次打包前都手动去修改`spring.profiles.active`的值。
	
例如在生产环境，我们可以使用release配置执行jar包`java -jar xxx.jar --spring.profiles.active=release`

如若配置:

```xml
spring:
  profiles:
    active: dev #默认为开发环境
```

会启动:`application.yml`与`application-dev.yml`

# config

## BoyingSecurityConfig

boying-security模块相关配置,在里面为UserDetailsService定义一个适用与boying-user组件的获取登录用户信息的方法。

```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class BoyingSecurityConfig extends SecurityConfig {

    @Autowired
    private BoyingUserService boyingUserService;

    /**
     * 注解@Bean放在方法上，产生一个Bean并且交给Spring容器管理
     * 定义用户信息
     */
    @Bean
    public UserDetailsService userDetailsService() {
        //为UserDetailsService定义一个适用与boying-user组件的获取登录用户信息的方法
        return username -> boyingUserService.loadUserByUsername(username);
    }
    //不添加基于路径的动态权限控制
}
```

## BoyingUserDetails

```java
/**
 * SpringSecurity需要的用户详情
 */
public class BoyingUserDetails implements UserDetails {
    private final BoyingUser user;

    public BoyingUserDetails(BoyingUser user) {
        this.user = user;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        //返回当前用户的角色
        return Arrays.asList(new SimpleGrantedAuthority("TEST"));
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUsername();
    }
    @Override
    public boolean isEnabled() {
        return user.getAdminDelete();
    }
}
```

## GlobalCorsConfig

全局跨域相关配置

## JacksonConfig

Jackson相关配置类,使得json不返回null的字段

## MyBatisConfig

MyBatis相关配置，控制dao或者mapper文件扫描位置

## SwaggerConfig

对boying-common的swagger相关组件进行自定义配置。Swagger API文档相关配置，主要是api扫描位置以及标题等

# param

用于将前端请求的参数封装成对象传递给service层，避免需要修改参数时controller、service方法传递的参数都要改变，编程过于繁琐

```java
@Getter
@Setter
@ToString
public class UserOrderParam {
    @ApiModelProperty(value = "showId")
    @NotNull(message = "演出Id不能为空")
    private Integer showId;

    @ApiModelProperty(value = "seatId")
    @NotNull(message = "演出座次Id不能为空")
    private Integer seatId;

    @ApiModelProperty(value = "promoId")
    private Integer promoId;

    @ApiModelProperty(value = "购买的票数（最多三张)")
    @NotNull(message = "购买的演出票数不能为空")
    @Max(3)
    @Min(1)
    private Integer count;

    @ApiModelProperty(value = "订单支付方式")
    @NotEmpty(message = "订单支付方式不能为空!")
    private String payment;
}
```



# VO、DTO

因为数据库表实体经常拆分

dataObject与数据库中一一映射

在service层有一个领域模型model的概念

返回给前端视图对象VO（View Object），因为一些用户敏感信息不应该被返回



所以在mapper中查询到dataObject后，需要组装成领域模型

在controller层调用service层返回给前端信息时，需要将领域模型转为VO

# Redis

## 验证码

生成验证码时，将自定义的Redis键值加上手机号生成一个Redis的key，以验证码为value存入到Redis中，并设置过期时间为自己配置的时间（这里为120s），并调用阿里云短信服务向手机号发送短信。校验验证码时根据手机号码来获取Redis里面存储的验证码，并与传入的验证码进行比对。

```java
# 自定义redis key
redis:
  database: boying
  key:
    authCode: 'user:authCode'
    user: 'user'
  expire:
    authCode: 90 # 验证码超期时间
    common: 86400 # 24小时


@Value("${redis.database}")
private String REDIS_DATABASE;
//    除验证码之外的过期时间
@Value("${redis.expire.common}")
private Long REDIS_EXPIRE;
@Value("${redis.expire.authCode}")
private Long REDIS_EXPIRE_AUTH_CODE;
//    用户以及验证码
@Value("${redis.key.user}")
private String REDIS_KEY_USER;
@Value("${redis.key.authCode}")
private String REDIS_KEY_AUTH_CODE;

@Override
public void setAuthCode(String telephone, String authCode) {
    String key = REDIS_DATABASE + ":" + REDIS_KEY_AUTH_CODE + ":" + telephone;
    //redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
    redisService.set(key, authCode, REDIS_EXPIRE_AUTH_CODE);
}

@Override
public String getAuthCode(String telephone) {
    String key = REDIS_DATABASE + ":" + REDIS_KEY_AUTH_CODE + ":" + telephone;
    return (String) redisService.get(key);
}
```

每次使用完毕（注册、更新密码等）都要删除密码

```java
//注册完删除验证码,每个验证码只能使用一次
boyingUserCacheService.delAuthCode(telephone);
```



## 用户信息

登录时，若缓存没有信息，则存入Redis中（用户名，用户信息）（手机号，用户信息）

```java
//boyingUserCacheService.setUser(user);//将查询到的数据放入缓存中

@Override
    public void setUser(BoyingUser user) {
        String key = REDIS_DATABASE + ":" + REDIS_KEY_USER + ":" + user.getUsername();
        String key2 = REDIS_DATABASE + ":" + REDIS_KEY_USER + ":" + user.getPhone();
//        设置两条,能通过手机号,用户名查到该用户
        redisService.set(key, user, REDIS_EXPIRE);
        redisService.set(key2, user, REDIS_EXPIRE);
    }
```

更新个人信息时，删除缓存

```java
    @Override
    public void delUser(int userId) {
//        确保全局不会redis缓存key混乱
        BoyingUser user = boyingUserMapper.selectByPrimaryKey(userId);
        if (user != null) {
            String key = REDIS_DATABASE + ":" + REDIS_KEY_USER + ":" + user.getUsername();
            String key2 = REDIS_DATABASE + ":" + REDIS_KEY_USER + ":" + user.getPhone();
            redisService.del(key);
            redisService.del(key2);
        }
    }
```



# 活动

如果没有领域模型，处理起来很麻烦。

```java
 查询演出信息时，在List<BoyingSeatModel> getShowSeatList(Integer showId);等得到座次的方法中，BoyingSeatModel聚合了一个BoyingPromoModel，如果promoModel不为空，则表示其拥有还未结束的秒杀活动

BoyingPromoModel boyingPromoModel = boyingPromoService.getPromo(seatDO.getId());
 //存在秒杀活动，而且是未开始或者是正在进行中的
 if (boyingPromoModel != null && boyingPromoModel.getStatus() != 3) {
 boyingSeatModel.setBoyingPromoModel(boyingPromoModel);
 }
 
 
 BoyingPromoServiceImpl的getPromo(Integer seatId)将数据库中对应座次的秒杀活动取出来，如果不存在则返回null，并且转换为BoyingPromoModel（多了一个status字段表示秒杀活动状态 1表示还未开始，2表示进行中，3表示已结束）
 
 
  在返回给前端时，如果该演出座次有秒杀活动则返回给前端，没有则不返回
if (boyingSeatModel.getBoyingPromoModel() != null) {
	//有正在进行或即将进行的秒杀活动
	boyingSeatVO.setPromoStatus(boyingSeatModel.getBoyingPromoModel().getStatus());
    boyingSeatVO.setPromoId(boyingSeatModel.getBoyingPromoModel().getId());
    boyingSeatVO.setStartTime(boyingSeatModel.getBoyingPromoModel().getStartTime());
    boyingSeatVO.setPromoPrice(boyingSeatModel.getBoyingPromoModel().getPrice());
} 
else {
	boyingSeatVO.setPromoStatus(0);
}
```



# Jmeter

测试针对的是获取演出详情接口，该接口是直接通过主键查询

一共启动200个线程，每个线程在10s内发送访问请求，每个循环20次

单台机器时访问耗时大约300ms

负载均衡后，只用了50ms

## 单台机器

首先，假如要使用大量线程的话，ramp-up period 一般不要设置成零。

​    因为假如设置成零，Jmeter将会在测试的开始就建立全部线程并立即发送访问请求， 这样一来就很轻易使服务器饱和，更重要的是会隐性地增加了负载，这就意味着服务器将可能过载，不是因为平均访问率高而是因为所有线程的第一次并发访问而引起的不正常的初始访问峰值，可以通过Jmeter的聚合报告监听器看到这种现象。
**这种异常不是我们需要的，因此，确定一个合理的ramp-up period 的规则就是让初始点击率接近平均点击率**。当然，也许需要运行一些测试来确定合理访问量。

　　基于同样的原因，过大的ramp-up period 也是不恰当的，因为将会降低访问峰值的负载，换句话说，在一些线程还未启动时，初期启动的部分线程可能已经结束了。

　　那么，如何检验ramp-up period I太小了或者太大了呢？首先，**初始的ramp-up period=平均点击率并用总线程/点击率**。 例如，假设线程数为100， 估计的点击率为每秒10次， 那么估计的理想ramp-up period 就是 100/10 = 10 秒。 那么，应怎样来提出一个合理的平均点击率呢？没有什么好办法，必须通过运行一次测试脚本来获得。

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612260464_2.png)

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612260578_3.png)

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612271452_8.png)

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612271506_9.png)

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612271539_10.png)

## 负载均衡后

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612273640_12.png)

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612515047_1.png)

# Nginx

## 介绍

+ 高性能的HTTP和反向代理服务器，占用内存小，并发能力强
+ 可以作为静态页面的web服务器
+ 注重性能，能经受高负载，支持超过50000个并发连接数



## 配置

```
47.103.203.188 部署数据库
101.132.157.174 部署Jar包1
47.100.47.244  ABC123456 部署Jar包2
47.100.88.187 sjs@2021 部署Nginx服务器 
```



```
先利用/usr/local/nginx/sbin/nginx -t测试配置文件修改是否正常
/usr/local/nginx/sbin/nginx -s reload重新加载
./nginx -s reload
ps -aux | grep nginx
./nginx -s stop
vim /usr/local/nginx/conf/nginx.conf

```



```
upstream boying {
    server  101.132.157.174:8000 weight=1;
    server  47.100.47.244:8000 weight=1;
    keepalive 30;
}

server {
    listen      8000;
    server_name 47.100.88.187;

    location / {
        root   html;
        index  index.html index.htm swagger-ui.html;
        proxy_pass  http://boying;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }
}
```



## 反向代理

### 正向代理

在客户端（浏览器）配置代理服务器，依赖代理服务器来访问真正的服务器

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612261754_4.png)

### 反向代理

+ 客户对代理无感知，客户端不需要做如何配置
+ 反向代理服务器和目标服务器对外就是一个服务器
+ 暴露的是代理服务器地址，隐藏了真实服务器IP地址

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612262060_5.png)

## 负载均衡

通过反向代理服务器，把请求通过Nginx平均分配到不同的服务器中

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612262371_6.png)

## 动静结合

加快网站的解析速度，把动态页面和静态页面由不同的服务器来解析，加快解析速度，降低单个服务器的压力

![img](https://tongji2021.oss-cn-shanghai.aliyuncs.com/img/_CopyPix_1612262513_7.png)

 